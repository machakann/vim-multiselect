Describe Event
	Before
		let Item = g:MS.Item
	End

	Before all
		%delete
		call append(0, [
			\ 'aaaaaaa',
			\ 'bbbbbbb',
			\ 'ccccccc',
			\ 'ddddddd',
			\ 'eeeeeee',
			\ ])
		$delete
		unlet! multiselector
	End

	Context .set(expr)
		It sets a autocmd task for the Event
			let multiselector = g:MS.Multiselector()

			let g:count = 0
			call multiselector.event.BufLeave.set('let g:count += 1')
			Assert Equals(g:count, 0)
			doautocmd <nomodeline> multiselect-events BufLeave
			Assert Equals(g:count, 1)

			let g:eventname = ''
			call multiselector.event.BufLeave.set({_ -> execute('let g:count += 1')})
			call multiselector.event.BufLeave.set({event -> execute('let g:eventname = event')})
			doautocmd <nomodeline> multiselect-events BufLeave
			Assert Equals(g:count, 3)
			Assert Equals(g:eventname, 'BufLeave')

			unlet! g:count g:eventname
			call filter(multiselector, 0)
		End
	End

	Context .unset(id)
		It removes a autocmd
			let multiselector = g:MS.Multiselector()
			let n = len(multiselector.event.BufLeave._orderlist)

			let id = multiselector.event.BufLeave.set('echo ""')
			Assert LengthOf(multiselector.event.BufLeave._orderlist, n + 1)

			call multiselector.event.BufLeave.unset(id)
			Assert LengthOf(multiselector.event.BufLeave._orderlist, n)

			call filter(multiselector, 0)
		End
	End

	Context .on()/.off()
		It turns on/off an autocmd event
			let multiselector = g:MS.Multiselector()
			let item1 = Item([0, 1, 1, 0], [0, 1, 1, 0], 'v')
			let added = [item1]
			call multiselector.extend(added)

			Assert True(multiselector.event.BufLeave.isactive())
			doautocmd <nomodeline> multiselect-events BufLeave
			Assert LengthOf(multiselector.itemlist, 0)

			call multiselector.extend(added)

			call multiselector.event.BufLeave.off()
			Assert False(multiselector.event.BufLeave.isactive())
			doautocmd <nomodeline> multiselect-events BufLeave
			Assert False(empty(multiselector.itemlist))

			call multiselector.event.BufLeave.on()
			Assert True(multiselector.event.BufLeave.isactive())
			doautocmd <nomodeline> multiselect-events BufLeave
			Assert True(empty(multiselector.itemlist))
		End
	End

	Context .skip()
		It sets a count to ignore autocmd events
			let multiselector = g:MS.Multiselector()
			let item1 = Item([0, 1, 1, 0], [0, 1, 1, 0], 'v')
			let added = [item1]
			call multiselector.extend(added)

			Assert True(multiselector.event.BufLeave.isactive())
			call multiselector.event.BufLeave.skip(1)
			Assert False(multiselector.event.BufLeave.isactive())
			Assert False(empty(multiselector.itemlist))

			doautocmd <nomodeline> multiselect-events BufLeave
			Assert True(multiselector.event.BufLeave.isactive())
			Assert False(empty(multiselector.itemlist))

			doautocmd <nomodeline> multiselect-events BufLeave
			Assert True(multiselector.event.BufLeave.isactive())
			Assert True(empty(multiselector.itemlist))

			call multiselector.uncheckall()
			call multiselector.extend(added)

			Assert True(multiselector.event.BufLeave.isactive())
			call multiselector.event.BufLeave.skip(2)
			Assert False(multiselector.event.BufLeave.isactive())
			Assert False(empty(multiselector.itemlist))

			doautocmd <nomodeline> multiselect-events BufLeave
			Assert False(multiselector.event.BufLeave.isactive())
			Assert False(empty(multiselector.itemlist))

			doautocmd <nomodeline> multiselect-events BufLeave
			Assert True(multiselector.event.BufLeave.isactive())
			Assert False(empty(multiselector.itemlist))

			doautocmd <nomodeline> multiselect-events BufLeave
			Assert True(multiselector.event.BufLeave.isactive())
			Assert True(empty(multiselector.itemlist))

			call multiselector.uncheckall()
			call multiselector.extend(added)

			Assert True(multiselector.event.BufLeave.isactive())
			call multiselector.event.BufLeave.skip(0)
			Assert True(multiselector.event.BufLeave.isactive())

			doautocmd <nomodeline> multiselect-events BufLeave
			Assert True(multiselector.event.BufLeave.isactive())
			Assert True(empty(multiselector.itemlist))

			call filter(multiselector, 0)
		End
	End

	Context CmdwinEnter/CmdwinLeave events
		It suspend/resume Multiselect.itemlist
			let multiselector = g:MS.Multiselector()
			let item1 = Item([0, 1, 1, 0], [0, 1, 1, 0], 'v')
			let item2 = Item([0, 2, 1, 0], [0, 2, 1, 0], 'v')
			let item3 = Item([0, 3, 1, 0], [0, 3, 1, 0], 'v')

			call multiselector.extend([item1])

			Assert LengthOf(multiselector.itemlist, 1)
			Assert Equals(multiselector._last.event, 'check')
			Assert Equals(multiselector._last.itemlist, sort([item1]))

			doautocmd <nomodeline> multiselect-events CmdwinEnter
			Assert LengthOf(multiselector.itemlist, 0)
			Assert Equals(multiselector._last.event, '')
			Assert Equals(multiselector._last.itemlist, [])

			call multiselector.extend([item2, item3])
			Assert LengthOf(multiselector.itemlist, 2)
			Assert Equals(multiselector._last.event, 'check')
			Assert Equals(sort(multiselector._last.itemlist), sort([item2, item3]))

			doautocmd <nomodeline> multiselect-events CmdwinLeave
			Assert LengthOf(multiselector.itemlist, 1)
			Assert Equals(multiselector._last.event, 'check')
			Assert Equals(multiselector._last.itemlist, [item1])

			call filter(multiselector, 0)
		End
	End

	Context Init event
		It is triggered when a Multiselector instance is produced
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestInit let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			let multiselector = g:MS.Multiselector({'eventinit': 'TestInit'})
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End

		It is triggered when BufLeave event is triggered
			let multiselector = g:MS.Multiselector({'eventinit': 'TestInit'})
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestInit let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			doautocmd <nomodeline> multiselect-events BufLeave
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End

		It is triggered when TabLeave event is triggered
			let multiselector = g:MS.Multiselector({'eventinit': 'TestInit'})
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestInit let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			doautocmd <nomodeline> multiselect-events TabLeave
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End

		It is triggered when CmdwinLeave event is triggered
			let multiselector = g:MS.Multiselector({'eventinit': 'TestInit'})
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestInit let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			doautocmd <nomodeline> multiselect-events CmdwinLeave
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End
	End

	Context CheckPost event
		It is triggered when Multiselect.check() method is called
			let multiselector = g:MS.Multiselector({'eventcheckpost': 'TestCheckPost'})
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestCheckPost let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			call multiselector.check([0, 1, 1, 0], [0, 1, 1, 0])
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End

		It is triggered when Multiselect.extend() method is called
			let multiselector = g:MS.Multiselector({'eventcheckpost': 'TestCheckPost'})
			let item = g:MS.Item([0, 1, 1, 0], [0, 1, 1, 0])
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestCheckPost let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			call multiselector.extend([item])
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End

		It is triggered when Multiselect.add() method is called
			let multiselector = g:MS.Multiselector({'eventcheckpost': 'TestCheckPost'})
			let item = g:MS.Item([0, 1, 1, 0], [0, 1, 1, 0])
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestCheckPost let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			call multiselector.add(item)
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End
	End

	Context UncheckPost event
		It is triggered when Multiselect.uncheck() method is called
			let multiselector = g:MS.Multiselector({'eventuncheckpost': 'TestUncheckPost'})
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestUncheckPost let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			call multiselector.check([0, 1, 1, 0], [0, 1, 1, 0])
			Assert Equals(g:count, 0)
			call multiselector.uncheck([0, 1, 1, 0])
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End

		It is triggered when Multiselect.emit() method is called
			let multiselector = g:MS.Multiselector({'eventuncheckpost': 'TestUncheckPost'})
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestUncheckPost let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			call multiselector.check([0, 1, 1, 0], [0, 1, 1, 0])
			Assert Equals(g:count, 0)
			call multiselector.emit()
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End

		It is triggered when Multiselect.remove() method is called
			let multiselector = g:MS.Multiselector({'eventuncheckpost': 'TestUncheckPost'})
			let g:count = 0
			augroup test
				autocmd!
				autocmd User TestUncheckPost let g:count += 1
			augroup End

			Assert Equals(g:count, 0)
			call multiselector.check([0, 1, 1, 0], [0, 1, 1, 0])
			Assert Equals(g:count, 0)
			call multiselector.remove(0)
			Assert Equals(g:count, 1)

			augroup test
				autocmd!
			augroup End
			unlet! g:count
			call filter(multiselector, 0)
		End
	End
End
" vim:set noet ts=4 sw=4 sts=-1:
