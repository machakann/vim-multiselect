*multiselect.txt*	複数選択ライブラリ
						Last change:12-Jan-2019.

書いた人   : machakann <https://github.com/machakann>
ライセンス : MIT license
Copyright (c) 2017 Masaaki Nakamura {{{

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
}}}

動作要件:	Vim 8.0 or higher

==============================================================================
目次
INDEX					*multiselect-index*

序 INTRODUCTION				|multiselect-introduction|
キーマッピング KEYMAPPINGS		|multiselect-keymappings|
ハイライトグループ HIGHLIGHT GROUPS	|multiselect-higroups|
自動コマンドイベント AUTOCMD EVENTS	|multiselect-events|
プラグインの作り方 HOW TO MAKE A PLUGIN	|multiselect-howtomakeaplugin|
プログラミングインターフェース API	|multiselect-api|

==============================================================================
序
INTRODUCTION				*multiselect-introduction*

*multiselect.vim* は複数のビジュアル選択を扱うためのライブラリプラグインです。
この複数選択は基本的に次のルールに従います。

	1. 二つの選択は重ならない、常に新しいものが古いものを解除する。
	2. 現在のバッファが編集されたとき、すべて選択は解除される。
	3. 別のバッファへ移動したとき、すべて選択は解除される。
	4. 別のタブへ移動したとき、すべて選択は解除される。 |tabpage|

このプラグイン自体は選択と選択解除の機能のみを提供します。
|multiselect-keymappings|

編集のための機能は他のプラグインによって提供されるでしょう。これらのプラグイン
を作るために Application Programming Interfaces (API) が利用できます。
|multiselect-api|

==============================================================================
キーマッピング
KEYMAPPINGS				*multiselect-keymappings*

以下のキーマッピングは |:nmap| および |:xmap| コマンドにより使用できます。

<Plug>(multiselect-check)		*<Plug>(multiselect-check)*
	このキーマッピングは現在の選択範囲を複数選択のひとつとします。ノーマル
	モードではカーソル下の単語 |word| を複数選択とします。


<Plug>(multiselect-checksearched)	*<Plug>(multiselect-checksearched)*
	このキーマッピングは最後に検索したパターン |@/| にマッチするテキストを
	現在バッファ上で検索し、複数選択とします。ノーマルモードではバッファ全
	体から検索し、ビジュアル選択モードでは選択範囲の中から検索します。

	NOTE: 次のキーマッピングはカーソル下の単語にマッチするテキストを選択し
	      ます。
>
	nmap <Space>v *N<Plug>(multiselect-checksearched)
<

<Plug>(multiselect-uncheck)		*<Plug>(multiselect-uncheck)*
	このキーマッピングは複数選択を解除します。ノーマルモードではカーソル下
	の複数選択を、ビジュアルモードでは選択範囲に含まれる複数選択を解除しま
	す。


<Plug>(multiselect-uncheckall)		*<Plug>(multiselect-uncheckall)*
	このキーマッピングはすべての複数選択を解除します。


<Plug>(multiselect-undo)		*<Plug>(multiselect-undo)*
	このキーマッピングは最後の選択・選択解除の動作を巻き戻します。


[count]<Plug>(multiselect-next)		*<Plug>(multiselect-next)*
	このキーマッピングは次の複数選択位置へカーソルを動かします。


[count]<Plug>(multiselect-previous)	*<Plug>(multiselect-previous)*
	このキーマッピングは前の複数選択位置へカーソルを動かします。


<Plug>(multiselect)			*<Plug>(multiselect)*
	このキーマッピングの挙動は少し複雑ですが、便利なものです。
	このキーマッピングはモードや条件によって動作を変え、選択と絞り込みを行
	います。

	ノーマルモード |Normal|:
	カーソル下の単語 |word| にマッチする文字列をバッファにわたって検索して
	選択します。もし、カーソル下が既に選択されていればその選択の中からマッ
	チする文字列を検索して選択します。

	文字単位のビジュアルモード |characterwise-visual|:
	ビジュアル選択範囲に複数選択が含まれる場合、選択範囲の外の複数選択を選
	択解除します。

	ビジュアル選択範囲が別の複数選択範囲の中に含まれている場合、ビジュアル
	選択されている文字列にマッチする文字列をその複数選択範囲の中から検索し
	て選択します。

	それ以外の場合はビジュアル選択されている文字列にマッチする文字列をバッ
	ファにわたって検索して選択します。

	行単位あるいは矩形ビジュアルモード
	|linewise-visual| or |blockwise-visual|:
	ビジュアル選択範囲に複数選択が含まれる場合、選択範囲の外の複数選択を選
	択解除します。

	それ以外の場合はビジュアル選択されている範囲を選択します。


					*multiselect-broadcasting-textobject*
ブロードキャストテキストオブジェクト~

次のテキストオブジェクト群は基本的にそのもととなったテキストオブジェクトと同様
に動作しますが、行単位ビジュアルモード |linewise-visual| のみにおいて少し変わ
った動作をします。これらは行単位ビジュアルモードでは各行に対して、カーソル桁位
置からもとのテキストオブジェクトをばらまきます。これは矩形ビジュアルモード
|blockwise-visual| に似ていますが、もはや対象は矩形でなくても構いません。例え
ば、次のようなバッファでは `<Plug>(multiselect-iw)` は "foo", "bar", "baz" を
選択することができます。 >
	foo
	 bar
	  baz
<
注意: これらのキーマッピングには既知の問題があります。テキストオブジェクトの
      対象が一文字の場合上手く動作しない場合があります。下のバッファの二行目、
      "a" は選択に失敗するでしょう。 >
	foo
	  a
	  baz
<
|:xmap| とあわせて使います。
>
	xmap iw <Plug>(multiselect-iw)
<

<Plug>(multiselect-iw)			*<Plug>(multiselect-iw)*
	|iw| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-aw)			*<Plug>(multiselect-aw)*
	|aw| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-iW)			*<Plug>(multiselect-iW)*
	|iW| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-aW)			*<Plug>(multiselect-aW)*
	|aW| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-i')			*<Plug>(multiselect-i')*
	|i'| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-a')			*<Plug>(multiselect-a')*
	|a'| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-i")			*<Plug>(multiselect-iquote)*
	|iquote| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-a")			*<Plug>(multiselect-aquote)*
	|aquote| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-i`)			*<Plug>(multiselect-i`)*
	|i`| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-a`)			*<Plug>(multiselect-a`)*
	|a`| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-i()			*<Plug>(multiselect-i()*
	|i(| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-a()			*<Plug>(multiselect-a()*
	|a(| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-i[)			*<Plug>(multiselect-i[)*
	|i[| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-a[)			*<Plug>(multiselect-a[)*
	|a[| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-i{)			*<Plug>(multiselect-i{)*
	|i{| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-a{)			*<Plug>(multiselect-a{)*
	|a{| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-it)			*<Plug>(multiselect-it)*
	|it| のブロードキャストテキストオブジェクトです。

<Plug>(multiselect-at)			*<Plug>(multiselect-at)*
	|at| のブロードキャストテキストオブジェクトです。


==============================================================================
ハイライトグループ
HIGHLIGHT GROUPS			*multiselect-higroups*

複数選択位置は通常のビジュアル選択と同じようにハイライトされます。この色は以下
のハイライトグループによって変更が可能です。

MultiselectItem				*hl-MultiselectItem*
	複数選択位置を示すハイライトグループです。デフォルトでは
	|hl-VisualNOS| へリンクされます。
>
		highlight default link MultiselectItem VisualNOS
<
	ただし |hl-VisualNOS| が存在しない場合 |hl-Visual| へリンクされます。
>
		highlight default link MultiselectItem Visual
<
	色は |:highlight| コマンドを使って設定することができます。 >
		highlight MultiselectItem ctermfg=White ctermbg=Red
		                               \ guifg=White   guibg=Red
<

==============================================================================
自動コマンドイベント
AUTOCMD EVENTS				*multiselect-events*

MultiselectEnter			*MultiselectEnter*
	`Multiselector` が生成された時に一度だけ発生します。対応プラグインを読
	み込むのに便利でしょう。


MultiselectCheckPost			*MultiselectCheckPost*
	テキストが複数選択として加えられた時に発生します。
>
		autocmd User MultiselectCheckPost echom 'Check!'
<
	この時 `Multiselector.lastevent()` を使うことで新しく加えられた複数選
	択位置の情報を得られるでしょう。
	|multiselect-Multiselector.lastevent()|


MultiselectUncheckPost			*MultiselectUncheckPost*
	複数選択を解除したときに発生します。
>
		autocmd User MultiselectUncheckPost echom 'Uncheck!'
<
	この時 `Multiselector.lastevent()` を使うことで解除された複数選択位置
	の情報を得られるでしょう。
	|multiselect-Multiselector.lastevent()|


==============================================================================
プラグインの作り方
HOW TO MAKE A PLUGIN			*multiselect-howtomakeaplugin*

複数選択を扱うプラグインを作るのは難しくありません。ここでは複数選択位置を編集
し、文字列 "foo" に置き換える機能を実装してみましょう。これはもちろん役にたつ
ものではありませんが、どのようにして API をつかうのかを学ぶよい例になるでしょ
う。 |multiselect-api| の項も参考にしてください。

前準備~
まずヘルプの |write-plugin| を読みましょう。そして実装を記述するファイルを用意
します。 >
	~/.vim/plugin/fooize.vim
<
今回は簡単のためこのファイルにすべてを記述しますが、 Vim の立ち上がりの高速化
のために |autoload| スクリプトを使うことはプラグインを作るうえで良い習慣です。



ステップ 1~
最初にやることは `Multiselect` モジュールを読み込み、 `Multiselector` インスタ
ンスを得ることです。
>
	" Multiselect module
	let s:Multiselect = multiselect#import()
<
`Multiselect` モジュールはいくつかの関数や定数などを保持していますが、なかでも
必須のものが `Multiselect.load()` 関数です。
この関数は `Multiselector` オブジェクトを返します。
>
	" Multiselector instance
	let s:multiselector = s:Multiselect.load()
<
このオブジェクトを使って複数選択を扱います。



ステップ 2~
次に、複数選択の位置を得ましょう。すでに選択されていれば、
`Multiselector.emit()` メソッドが複数選択を解除しその情報を返します。
>
	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif
	endfunction
<
それでは一つ一つの要素を処理していきましょう。この要素は `Item` オブジェクト
|multiselect-object-Item| であり、 複数選択の位置をビジュアル選択しなおす
`Item.select()` というメソッドを持っています。これを使って対象を順に処理して
いきます。

実際のバッファの編集を開始しますが、一つコツがあります。それはバッファの末尾か
ら開始へ向かう順番で要素を編集することです。これは、バッファの先頭付近の要素の
編集によって末尾付近の要素の位置がずれることを避けるためです。要素の並べ替えに
は `Multiselector.sort()` 関数と組み込みの |reverse()| が使えます。
>
	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  for item in reverse(itemlist)
	    call item.select()
	    normal! cfoo
	  endfor
	endfunction
<
今回のようにバッファに文字列を挿入する場合、注意することがもう一つあります。
自動インデント機能です。これもまた編集位置のずれを生む可能性があります。これを
完全に避けることは難しいのですが 'indentkeys' (あるいは 'cinkeys') オプション
を一時的にデフォルト値に設定することで、かなりのリスクを抑えることができます。
|multiselect-Multiselect.shiftenv()| と |multiselect-Multiselect.restoreenv()|
をつかうと便利です。
>
	let s:shiftenv = s:Multiselect.shiftenv
	let s:restoreenv = s:Multiselect.restoreenv

	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  let env = s:shiftenv()
	  try
	    for item in reverse(itemlist)
	      call item.select()
	      normal! cfoo
	    endfor
	  finally
	    call s:restoreenv(env)
	  endtry
	endfunction
<


ステップ 3~
最後にインターフェースを実装しましょう。今回はコマンドとノーマルモード
|Normal| のキーマッピングを用意してみます。
>
	command! Fooize call Fooize()
	nnoremap <silent> <Space>f :<C-u>call Fooize()<CR>
<

最終的な成果物が以下です。
>
	if exists("g:loaded_fooize")
	  finish
	endif
	let g:loaded_fooize = 1

	let s:Multiselect = multiselect#import()
	let s:multiselector = s:Multiselect.load()
	let s:shiftenv = s:Multiselect.shiftenv
	let s:restoreenv = s:Multiselect.restoreenv

	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  let env = s:shiftenv()
	  try
	    for item in reverse(itemlist)
	      call item.select()
	      normal! cfoo
	    endfor
	  finally
	    call s:restoreenv(env)
	  endtry
	endfunction

	command! Fooize call Fooize()
	nnoremap <silent> <Space>f :<C-u>call Fooize()<CR>
<
これは `macros/multiselect/demo/fooize.vim` にあります。

==============================================================================
プログラミングインターフェース
API					*multiselect-api*

目次~

* Multiselect モジュール~
  Multiselect			|multiselect-module-Multiselect|
  multiselect#import()		|multiselect#import()|

  Multiselect.DEFAULTHIGROUP	|multiselect-Multiselect.DEFAULTHIGROUP|
  Multiselect.load()		|multiselect-Multiselect.load()|

  - constructors
  Multiselect.Region()		|multiselect-Multiselect.Region()|
  Multiselect.Item()		|multiselect-Multiselect.Item()|
  Multiselect.Change()		|multiselect-Multiselect.Change()|
  Multiselect.Task()		|multiselect-Multiselect.Task()|
  Multiselect.TaskChain()	|multiselect-Multiselect.TaskChain()|

  - utility functions
  Multiselect.shiftenv()	|multiselect-Multiselect.shiftenv()|
  Multiselect.restoreenv()	|multiselect-Multiselect.restoreenv()|
  Multiselect.str2type()	|multiselect-Multiselect.str2type()|
  Multiselect.str2visualcmd()	|multiselect-Multiselect.str2visualcmd()|
  Multiselect.inorderof()	|multiselect-Multiselect.inorderof()|
  Multiselect.inbetween()	|multiselect-Multiselect.inbetween()|
  Multiselect.isextended()	|multiselect-Multiselect.isextended()|

* Multiselector オブジェクト~
  Multiselector			|multiselect-object-Multiselector|

  - メンバ
  Multiselector.name		|multiselect-Multiselector.name|
  Multiselector.bufnr		|multiselect-Multiselector.bufnr|
  Multiselector.higroup		|multiselect-Multiselector.higroup|
  Multiselector.itemlist	|multiselect-Multiselector.itemlist|

  - 主要メソッド
  Multiselector.check()		|multiselect-Multiselector.check()|
  Multiselector.checkpattern()	|multiselect-Multiselector.checkpattern()|
  Multiselector.uncheck()	|multiselect-Multiselector.uncheck()|
  Multiselector.uncheckall()	|multiselect-Multiselector.uncheckall()|
  Multiselector.emit()		|multiselect-Multiselector.emit()|
  Multiselector.emit_inside()	|multiselect-Multiselector.emit_inside()|
  Multiselector.emit_touching()	|multiselect-Multiselector.emit_touching()|
  Multiselector.filter()	|multiselect-Multiselector.filter()|
  Multiselector.sort()		|multiselect-Multiselector.sort()|

  - キーマップメソッド
  Multiselector.keymap_check()
				|multiselect-Multiselector.keymap_check()|
  Multiselector.keymap_checkpattern()
			     |multiselect-Multiselector.keymap_checkpattern()|
  Multiselector.keymap_uncheck()
				|multiselect-Multiselector.keymap_uncheck()|
  Multiselector.keymap_uncheckall()
			       |multiselect-Multiselector.keymap_uncheckall()|
  Multiselector.keymap_undo()
				|multiselect-Multiselector.keymap_undo()|
  Multiselector.keymap_multiselect()
			      |multiselect-Multiselector.keymap_multiselect()|
  Multiselector.keymap_broadcast()
				|multiselect-Multiselector.keymap_broadcast()|

  - 基礎メソッド
  Multiselector.append()	|multiselect-Multiselector.append()|
  Multiselector.remove()	|multiselect-Multiselector.remove()|
  Multiselector.enumerate()	|multiselect-Multiselector.enumerate()|
  Multiselector.itemnum()	|multiselect-Multiselector.itemnum()|
  Multiselector.isempty()	|multiselect-Multiselector.isempty()|
  Multiselector.lastevent()	|multiselect-Multiselector.lastevent()|
  Multiselector.show()		|multiselect-Multiselector.show()|
  Multiselector.quench()	|multiselect-Multiselector.quench()|
  Multiselector.unsafe_append()	|multiselect-Multiselector.unsafe_append()|

  - イベントコントロール
  Multiselector.event()		|multiselect-Multiselector.event()|

* Region オブジェクト~
  Region			|multiselect-object-Region|
  Region.head			|multiselect-Region.head|
  Region.tail			|multiselect-Region.tail|
  Region.type			|multiselect-Region.type|
  Region.extended		|multiselect-Region.extended|
  Region.select()		|multiselect-Region.select()|
  Region.yank()			|multiselect-Region.yank()|
  Region.includes()		|multiselect-Region.includes()|
  Region.isinside()		|multiselect-Region.isinside()|
  Region.touches()		|multiselect-Region.touches()|

* Item オブジェクト~
  Item				|multiselect-object-Item|
  Item.id			|multiselect-Item.id|
  Item.bufnr			|multiselect-Item.bufnr|
  Item.head			|multiselect-Item.head|
  Item.tail			|multiselect-Item.tail|
  Item.type			|multiselect-Item.type|
  Item.extended			|multiselect-Item.extended|
  Item.select()			|multiselect-Item.select()|
  Item.yank()			|multiselect-Item.yank()|
  Item.includes()		|multiselect-Item.includes()|
  Item.isinside()		|multiselect-Item.isinside()|
  Item.touches()		|multiselect-Item.touches()|
  Item.show()			|multiselect-Item.show()|
  Item.quench()			|multiselect-Item.quench()|
  Item.isshownin()		|multiselect-Item.isshownin()|

* Change オブジェクト~
  Change			|multiselect-object-Change|
  Change.beforedelete()		|multiselect-Change.beforedelete()|
  Change.afterinsert()		|multiselect-Change.afterinsert()|
  Change.apply()		|multiselect-Change.apply()|
  Change.mapapply()		|multiselect-Change.mapapply()|

* NeatTask オブジェクト~
  NeatTask			|multiselect-object-NeatTask|
  NeatTask.call()		|multiselect-NeatTask.call()|
  NeatTask.execute()		|multiselect-NeatTask.execute()|
  NeatTask.append()		|multiselect-NeatTask.append()|
  NeatTask.trigger()		|multiselect-NeatTask.trigger()|
  NeatTask.clear()		|multiselect-NeatTask.clear()|
  NeatTask.isactive()		|multiselect-NeatTask.isactive()|
  NeatTask.skip()		|multiselect-NeatTask.skip()|
  NeatTask.repeat()		|multiselect-NeatTask.repeat()|
  NeatTask.leftcount()		|multiselect-NeatTask.leftcount()|
  NeatTask.hasdone()		|multiselect-NeatTask.hasdone()|

* Task オブジェクト~
  Task				|multiselect-object-Task|
  Task.waitfor()		|multiselect-Task.waitfor()|
  Task.cancel()			|multiselect-Task.cancel()|
  Task.call()			|multiselect-Task.call()|
  Task.execute()		|multiselect-Task.execute()|
  Task.append()			|multiselect-Task.append()|
  Task.trigger()		|multiselect-Task.trigger()|
  Task.clear()			|multiselect-Task.clear()|
  Task.isactive()		|multiselect-Task.isactive()|
  Task.skip()			|multiselect-Task.skip()|
  Task.repeat()			|multiselect-Task.repeat()|
  Task.leftcount()		|multiselect-Task.leftcount()|
  Task.hasdone()		|multiselect-Task.hasdone()|

* TaskChain オブジェクト~
  TaskChain			|multiselect-object-TaskChain|
  TaskChain.hook()		|multiselect-TaskChain.hook()|
  TaskChain.trigger()		|multiselect-TaskChain.trigger()|
  TaskChain.waitfor()		|multiselect-TaskChain.waitfor()|
  TaskChain.cancel()		|multiselect-TaskChain.cancel()|
  TaskChain.repeat()		|multiselect-TaskChain.repeat()|
  TaskChain.leftcount()		|multiselect-TaskChain.leftcount()|
  TaskChain.hasdone()		|multiselect-TaskChain.hasdone()|

------------------------------------------------------------------------------
Multiselect モジュール~
					*multiselect-module-Multiselect*

このモジュールが `Multiselector` オブジェクトを返す
|multiselect-Multiselect.load()| 関数を持っています。

他にもいくつかの便利な機能が集められており、必須ではありませんがプラグインを書
く際に便利かもしれません。


multiselect#import()			*multiselect#import()*
	この関数は `Multiselect` モジュールを返します。 >
		let s:Multiselect = multiselect#import()
<

				*multiselect-Multiselect.DEFAULTHIGROUP*
Multiselect.DEFAULTHIGROUP    [string]
	複数選択に対するハイライトグループ名、すなわち "MultiselectItem"
	です。


					*multiselect-Multiselect.load()*
Multiselect.load()    [function]
	`Multiselector` オブジェクトを返します。
	|multiselect-object-Multiselector| の項も参照してください。 >
		let s:multiselector = s:Multiselect.load()
<
	ユーザーはキーマッピングを通してこのオブジェクトとやりとりをします。
	|multiselect-keymappings|


  - コンストラクタ
					*multiselect-Multiselect.Region()*
Multiselect.Region({head}[, {tail}[, {type}[, {extended}]]])    [function]
Multiselect.Region({lnum})
Multiselect.Region({startlnum}, {endlnum})
	新しい `Region` オブジェクトを返します。これはバッファ上の一部分を表し
	ます。 |multiselect-object-Region|

	次の `Item` オブジェクトはこの `Region` の機能を継承します
	|multiselect-object-Item|

	{head} と {tail} は範囲の先頭と終端の位置です。これは |getpos()| 関数
	の返り値のように四要素のリストです。

	{type} は部分の種類です。 Vim はバッファ上の範囲を三種類に分類します。
	  "char" あるいは "v": 文字単位 |characterwise-visual|
	  "line" あるいは "V": 行単位 |linewise-visual|
	  "block" あるいは "\<C-v>": 矩形 |blockwise-visual|
	{type} が省略された場合、文字単位とみなされます。

	{extended} は {type} が矩形の場合にのみ意味を持ちます。これは真偽値
	(0 か 1) であり、真 |TRUE| (1) の時、その選択範囲の末尾桁を行の最終桁
	まで延伸します。これは |v_$| を使った場合と同じ意味を持ちます。
	{extended} が省略された場合は偽 |FALSE| (0) とみなされます。 >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let region = s:Multiselect.Region(head, tail, 'block', 1)
<
	引数が {head} のみの場合、 {head} と {tail} の等しい一文字の文字単位の
	範囲を返します。

	引数が数値 |Number| の {lnum} のみの場合、 {lnum} の指定する一行を表す
	行単位の範囲を返します。

	引数がともに数値 |Number| の {startlnum} と {endlnum} が与えられた
	場合、 {startlnum} 行から {endlnum} 行までの範囲を表す行単位の範囲を返
	します。


					*multiselect-Multiselect.Item()*
Multiselect.Item({head}[, {tail}[, {type}[, {extended}]]])   [function]
Multiselect.Item({lnum})
Multiselect.Item({startlnum}, {endlnum})
	新しい `Item` オブジェクトを返します。 `Region` オブジェクトの機能を
	継承しており、複数選択のひとつを表します。 |multiselect-object-Item|
	|multiselect-object-Region|

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let item = s:Multiselect.Item(head, tail, 'block', 1)
<

					*multiselect-Multiselect.Change()*
Multiselect.Change()    [function]
	新しい `Change` オブジェクトを返します。あるバッファ上の位置の、編集後
	の位置を追跡するために使われます。 |multiselect-object-Change|


					*multiselect-Multiselect.NeatTask()*
Multiselect.NeatTask()    [function]
	新しい `NeatTask` オブジェクトを返します。
	|multiselect-object-NeatTask|

	このオブジェクトはいくつかの処理を集めておいて、後ほど一度に実行するた
	めに使われます。また、次の `Task` オブジェクトは `NeatTask` の機能を
	継承します。
	|multiselect-object-Task|


					*multiselect-Multiselect.Task()*
Multiselect.Task()    [function]
	新しい `Task` オブジェクトを返します。 |multiselect-object-Task|
	自動コマンド |autocommand-events|、および経過時間 |timer| のいずれかに
	よって実行される処理を予約するために使われます。


					*multiselect-Multiselect.TaskChain()*
Multiselect.TaskChain()    [function]
	新しい `TaskChain` オブジェクトを返します。
	|multiselect-object-TaskChain|
	自動コマンド、および経過時間によって設定された順序で、数珠繋ぎとなった
	一連の処理を実行していくために使われます。


  - その他の関数
					*multiselect-Multiselect.shiftenv()*
Multiselect.shiftenv({expr}, {Filterexpr})    [function]
	'indentkeys' あるいは 'cinkeys' オプションをデフォルト値に設定し、ユー
	ザー設定を復元するための情報を返します。これは、
	|multiselect-Multiselect.restoreenv()| 関数の引数として使います。
	|multiselect-howtomakeaplugin| の項も参照してください。 >
		let s:shiftenv = s:Multiselect.shiftenv
		let s:restoreenv = s:Multiselect.restoreenv

		let indentopt = s:shiftenv()
		" do something
		call s:restoreenv(indentopt)
<

					*multiselect-Multiselect.restoreenv()*
Multiselect.restoreenv({expr}, {Filterexpr})    [function]
	|multiselect-Multiselect.shiftenv()| 関数の返り値を引数として受け取
	り、設定を復元します。
	|multiselect-howtomakeaplugin| の項も参照してください。 >
		let s:shiftenv = s:Multiselect.shiftenv
		let s:restoreenv = s:Multiselect.restoreenv

		let indentopt = s:shiftenv()
		" do something
		call s:restoreenv(indentopt)
<

					*multiselect-Multiselect.str2type()*
Multiselect.str2type({str})    [function]
	範囲 `Region` の種類を表す文字列を返します。
	{str} が "char" か "v" なら "char" を返します。
	{str} が "line" か "V" なら "line" を返します。
	{str} が "block" か "\<C-v>" なら "block" を返します。
	|visualmode()| の項も確認してください。 >
		let s:str2type = s:Multiselect.str2type

		let type = str2type('char')
		" type ==# 'char'

		let type = str2type('v')
		" type ==# 'char'

		let type = str2type('line')
		" type ==# 'line'

		let type = str2type('V')
		" type ==# 'line'

		let type = str2type('block')
		" type ==# 'block'

		let type = str2type("\<C-v>")
		" type ==# 'block'
<
	この関数は "\<C-v>" の後に続く数字を無視します。 このため、
	|getregtype()| の返り値は引数として有効です。 >
		let type = str2type("\<C-v>10")
		" type ==# 'block'
<

				*multiselect-Multiselect.str2visualcmd()*
Multiselect.str2visualcmd({str})    [function]
	範囲の種類を表す文字列を受け取り、特定のビジュアルモードへ入るためのコ
	マンドを返します。
	{str} が "char" か "v" の場合は "v" を返します。
	{str} が "line" か "V" の場合は "V" を返します。
	{str} が "block" か "\<C-v>" の場合は "\<C-v>" を返します。
	|visualmode()| の項も確認してください。 >
		let s:str2visualcmd = s:Multiselect.str2visualcmd

		let type = str2visualcmd('char')
		" type ==# 'v'

		let type = str2visualcmd('v')
		" type ==# 'v'

		let type = str2visualcmd('line')
		" type ==# 'V'

		let type = str2visualcmd('V')
		" type ==# 'V'

		let type = str2visualcmd('block')
		" type ==# "\<C-v>"

		let type = str2visualcmd("\<C-v>")
		" type ==# "\<C-v>"
<
	この関数は "\<C-v>" の後に続く数字を無視します。 このため、
	|getregtype()| の返り値は引数として有効です。 >
		let type = str2visualcmd("\<C-v>10")
		" type ==# "\<C-v>"
<

					*multiselect-Multiselect.inorderof()*
Multiselect.inorderof({pos1}, {pos2})    [function]
	{pos1} が {pos2} よりバッファ開始方向に位置していれば真 |TRUE| を、
	そうでなければ偽 |FALSE| を返します。
>
		let s:inorderof = s:Multiselect.inorderof

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inorderof([0, 2, 3, 0], [0, 3, 1, 0])
		" bool is TRUE

		let bool = s:inorderof([0, 2, 3, 0], [0, 1, 1, 0])
		" bool is FALSE

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 2, 0])
		" bool is FALSE

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 3, 0])
		" bool is FALSE
<

					*multiselect-Multiselect.inbetween()*
Multiselect.inbetween({pos}, {head}, {tail})    [function]
	This function returns |TRUE| is {pos} is in between {head} and {tail}.
	{pos} が {head} と {tail} の間に位置していれば真 |TRUE| を、そうでなけ
	れば偽 |FALSE| を返します。

	{head} と {tail} が {pos} と重なっている場合も真が返ります。
>
		let s:inbetween = s:Multiselect.inbetween
		let pos = [0, 2, 3, 0]

		let bool = s:inbetween(pos, [0, 2, 2, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 3, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 2, 0], [0, 2, 3, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 3, 0], [0, 2, 3, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 1, 1, 0], [0, 3, 1, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 1, 0], [0, 2, 2, 0])
		" bool is FALSE

		let bool = s:inbetween(pos, [0, 2, 4, 0], [0, 2, 5, 0])
		" bool is FALSE
<

					*multiselect-Multiselect.isextended()*
Multiselect.isextended()    [function]
	最後に使ったビジュアルモードが矩形ビジュアルモード |blockwise-visual|
	であり、さらに |v_$| が使われていた場合にのみ真 |TRUE| が返ります。 >
		let s:isextended = s:Multiselect.isextended

		execute "normal! \<C-v>2j$"
		execute "normal! \<Esc>"
		let bool = s:isextended()
		" bool is TRUE

		execute "normal! \<C-v>2j"
		execute "normal! \<Esc>"
		let bool = s:isextended()
		" bool is FALSE
<


------------------------------------------------------------------------------
Multiselector object~
					*multiselect-object-Multiselector*

`Multiselector` オブジェクトは `Multiselect` モジュールの `Multiselect.load()`
関数で得られます。

  - メンバ
					*multiselect-Multiselector.name*
Multiselector.name    [string]
	`Multiselector` オブジェクトの識別子です。機能に影響は及ぼしません。


					*multiselect-Multiselector.bufnr*
Multiselector.bufnr    [number]
	現在属しているバッファ番号です。どこにも属していなければ -1 になりま
	す。


					*multiselect-Multiselector.higroup*
Multiselector.higroup    [string]
	複数選択に対して適用されるハイライトグループの名前です。


					*multiselect-Multiselector.itemlist*
Multiselector.itemlist    [list]
	現在の複数選択要素を表す `Item` オブジェクトのリストです。

	NOTE: このリストは直接変更しないでください。 以下の `Multiselector`
	      オブジェクトのメソッドを使いましょう。


  - 主要メソッド
					*multiselect-Multiselector.check()*
Multiselector.check({head}[, {tail}[, {type}[, {extended}]]])    [method]
Multiselector.check({lnum})
Multiselector.check({startlnum}, {endlnum})
Multiselector.check({region})
	指定されたバッファの一範囲を複数選択として `Multiselector.itemlist` に
	加えます。この新しく生成された `Item` オブジェクトが返されます。
	|multiselect-Multiselector.itemlist|
	|multiselect-object-Item|

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'block', 1)
		call s:multiselector.check(region)
<

				    *multiselect-Multiselector.checkpattern()*
Multiselector.checkpattern({pat}[, {region}])    [method]
	正規表現 {pat} にマッチするテキストをバッファから検索し、複数選択とし
	て、 `Multiselect.itemlist` に加えます。新しく加えられた複数選択要素の
	リストが返されます。
	|multiselect-Multiselector.itemlist|


					*multiselect-Multiselector.uncheck()*
Multiselector.uncheck({head}[, {tail}[, {type}[, {extended}]]])    [method]
Multiselector.uncheck({lnum})
Multiselector.uncheck({startlnum}, {endlnum})
Multiselector.uncheck({region})
	指定された範囲に触れている複数選択要素を選択解除します。

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let region = s:Multiselect.Region(head, tail, 'line')
		call s:multiselector.uncheck(region)
<

				*multiselect-Multiselector.uncheckall()*
Multiselector.uncheckall()    [method]
	すべての複数選択を解除します。 >
		call s:multiselector.uncheckall()
<

					*multiselect-Multiselector.emit()*
Multiselector.emit([{Filterexpr}])    [method]
	複数選択を解除し、その要素のリストを返します。

	{Filterexpr} が省略された場合、すべての複数選択を解除しその要素のリス
	トを返します。 >
		let itemlist = s:multiselector.emit()
<
	{Filterexpr} は二つの引数を取る関数参照 |Funcref| です。{Filterexpr}
	が与えられた場合、すべての複数選択要素に対して要素のインデックスと要素
	自体を引数にあたえて評価し、{Filterexpr} が真 |TRUE| を返す要素につい
	て選択解除し返り値に返します。
	  - 例1: ビジュアル選択範囲内の要素を得る >
		let head = getpos("'<")
		let tail = getpos("'>")
		let type = visualmode()
		let region = s:Multiselect.Region(head, tail, type)
		let itemlist = s:multiselector.emit(
			\ {_, item -> item.isinside(region)})
<
	  NOTE: この用途にはかわりに `Multiselector.emit_inside()` を使うこと
	        ができます。
	        |multiselect-Multiselector.emit_inside()|

	  - 例2: カーソルに触れている要素を得る >
		let curpos = getpos('.')
		let itemlist = s:multiselector.emit(
			\ {_, item -> item.touches(curpos)})
<
	  NOTE: この用途にはかわりに `Multiselector.emit_touching()` を使うこ
	        とができます。
	        |multiselect-Multiselector.emit_touching()|


				*multiselect-Multiselector.emit_inside()*
Multiselector.emit_inside({head}[, {tail}[, {type}[, {extended}]]])   [method]
Multiselector.emit_inside({lnum})
Multiselector.emit_inside({startlnum}, {endlnum})
Multiselector.emit_inside({region})
	引数で指定された範囲の中に含まれている複数選択を解除し、その要素のリス
	トを返します。

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let head = getpos("'<")
		let tail = getpos("'>")
		let type = visualmode()
		let region = s:Multiselect.Region(head, tail, type)
		let itemlist = s:multiselector.emit_inside(region)
<
	このメソッドは上の `Multiselector.emit()` の例1に示されている場合のエ
	イリアスです。
	|multiselect-Multiselector.emit()|


				*multiselect-Multiselector.emit_touching()*
Multiselector.emit_touching({head}[, {tail}[, {type}[, {extended}]]]) [method]
Multiselector.emit_touching({lnum})
Multiselector.emit_touching({startlnum}, {endlnum})
Multiselector.emit_touching({region})
	引数で指定された範囲に触れている複数選択を解除し、その要素のリストを返
	します。

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let curpos = getpos('.')
		let itemlist = s:multiselector.emit_touching(curpos)
<
	このメソッドは上の `Multiselector.emit()` の例2に示されている場合のエ
	イリアスです。
	|multiselect-Multiselector.emit()|


					*multiselect-Multiselector.filter()*
Multiselector.filter({Filterexpr})    [method]
	このメソッドは与えられたフィルタ関数の関数参照 |Funcref| を使って
	`Multiselector.itemlist` 内の要素をフィルタします。
	|multiselect-Multiselector.itemlist|

	{Filterexpr} は二つの引数を取る関数参照 |Funcref| です。これはすべての
	複数選択要素に対して要素のインデックスと要素自体を引数にあたえて評価さ
	れ、{Filterexpr} が偽 |FALSE| を返す要素について選択解除します。

	返り値はフィルタ後の `Multiselector.itemlist` です。

	  - 例1: 五行目以外に存在する複数選択を解除する >
		let pos = [0, 5, 1, 0]
		let line5 = s:Multiselect.Region(pos, pos, 'V')
		call s:multiselector.filter(
			\ {_, item -> item.isinside(line5)})
<
	|multiselect-Multiselect.Region()|
	|multiselect-object-Region| |multiselect-object-Item|
	|multiselect-Region.isinside()|

	  - Example2: ビジュアル選択の外の複数選択を解除する >
		let vhead = getpos("'<")
		let vtail = getpos("'>")
		let vmode = visualmode()
		let visual = s:Multiselect.Region(vhead, vtail, vmode)
		call s:multiselector.filter(
			\ {_, item -> item.isinside(visual)})
<
	|multiselect-Multiselect.Region()|
	|multiselect-object-Region| |multiselect-object-Item|
	|multiselect-Region.isinside()|


					*multiselect-Multiselector.sort()*
Multiselector.sort({itemlist})    [function]
	与えられた複数選択要素のリスト {itemlist} をバッファ内の位置によって並
	べ替えます。バッファの開始に近い要素がリストの先頭に来ます。ただし、矩
	形の要素と文字単位の要素が同じ行にある場合は画面上の桁位置によって以下
	のように並べ替えられます。 >
		"#" represents selection and the number is the order in the
		sorted list

		##1##	#####	##4##
			##3##
		##2##	#####	##5##
<
	並べ替えは破壊的 (in-place) に行われます。必要であればもとのリストのコ
	ピーを取ってください。 >
		let copied = copy(itemlist)
		call s:multiselector.sort(copied)
<
	`Multiselector.enumerate()` メソッドの返り値も {itemlist} として有効で
	す。 >
		let itemlist = s:multiselector.enumerate()
		call s:multiselector.sort(itemlist)
<

  - キーマッピングメソッド
				*multiselect-Multiselector.keymap_check()*
Multiselector.keymap_check({mode})    [method]
	この関数はキーマッピング |<Plug>(multiselect-check)| の関数版です。

	ビジュアル選択範囲を複数選択に加えます。ノーマルモードではカーソル下の
	単語 |word| を加えます。

	{mode} は動作するモードを表す一文字です。ノーマル |Normal| モードなら
	'n' を、ビジュアル |Visual| モードなら 'x' を指定してください。


			     *multiselect-Multiselector.keymap_checkpattern()*
Multiselector.keymap_checkpattern({mode}, {pat})    [method]
	キーマッピング |<Plug>(multiselect-checksearched)| の基礎となる関数で
	す。

	正規表現 {pat} にマッチするテキストを検索し、複数選択として加えます。
	ビジュアルモードで使用すると、ビジュアル選択範囲の中から検索します。

	{mode} は動作するモードを表す一文字です。ノーマル |Normal| モードなら
	'n' を、ビジュアル |Visual| モードなら 'x' を指定してください。


				*multiselect-Multiselector.keymap_uncheck()*
Multiselector.keymap_uncheck({mode})    [method]
	キーマッピング |<Plug>(multiselect-uncheck)| の関数版です。

	ノーマルモードではカーソル下の複数選択要素を解除します。ビジュアルモー
	ドではビジュアル選択範囲に触れている複数選択要素を解除します。

	{mode} は動作するモードを表す一文字です。ノーマル |Normal| モードなら
	'n' を、ビジュアル |Visual| モードなら 'x' を指定してください。


			       *multiselect-Multiselector.keymap_uncheckall()*
Multiselector.keymap_uncheckall()    [method]
	キーマッピング |<Plug>(multiselect-uncheckall)| の関数版です。

	すべての複数選択を解除します。


				*multiselect-Multiselector.keymap_undo()*
Multiselector.keymap_undo()    [method]
	キーマッピング |<Plug>(multiselect-undo)| の関数版です。

	最後の選択・選択解除を取り消します。この取り消し可能な深さは現在一回だ
	けです。


			      *multiselect-Multiselector.keymap_next()*
Multiselector.keymap_next({mode})    [method]
	キーマッピング |<Plug>(multiselect-next)| の関数版です。

	カーソルを次の複数選択要素へ移動します。

	{mode} は動作するモードを表す一文字です。ノーマル |Normal| モードなら
	'n' を、ビジュアル |Visual| モードなら 'x' を指定してください。


			      *multiselect-Multiselector.keymap_previous()*
Multiselector.keymap_previous({mode})    [method]
	キーマッピング |<Plug>(multiselect-previous)| の関数版です。

	カーソルを前の複数選択要素へ移動します。

	{mode} は動作するモードを表す一文字です。ノーマル |Normal| モードなら
	'n' を、ビジュアル |Visual| モードなら 'x' を指定してください。


			      *multiselect-Multiselector.keymap_multiselect()*
Multiselector.keymap_multiselect({mode})    [method]
	キーマッピング |<Plug>(multiselect)| の関数版です。

	ノーマルモード |Normal|:
	カーソル下の単語 |word| にマッチする文字列をバッファにわたって検索して
	選択します。もし、カーソル下が既に選択されていればその選択の中からマッ
	チする文字列を検索して選択します。

	文字単位のビジュアルモード |characterwise-visual|:
	ビジュアル選択範囲に複数選択が含まれる場合、選択範囲の外の複数選択を選
	択解除します。

	ビジュアル選択範囲が別の複数選択範囲の中に含まれている場合、ビジュアル
	選択されている文字列にマッチする文字列をその複数選択範囲の中から検索し
	て選択します。

	それ以外の場合はビジュアル選択されている文字列にマッチする文字列をバッ
	ファにわたって検索して選択します。

	行単位あるいは矩形ビジュアルモード
	|linewise-visual| or |blockwise-visual|:
	ビジュアル選択範囲に複数選択が含まれる場合、選択範囲の外の複数選択を選
	択解除します。

	{mode} は動作するモードを表す一文字です。ノーマル |Normal| モードなら
	'n' を、ビジュアル |Visual| モードなら 'x' を指定してください。


				*multiselect-Multiselector.keymap_broadcast()*
Multiselector.keymap_broadcast({cmd})   [method]
	ブロードキャストテキストオブジェクトを生成する関数です。

	{cmd} はモーション {motion} コマンドか、テキストオブジェクト
	|text-objects| です。このメソッドはビジュアルモードでのみ動作し、文字
	単位 |characterwise-visual| あるいは矩形 |blockwise-visual| ビジュアル
	モードではもとの {cmd} と同じように働きます。
	
	行単位 |linewise-visual| ビジュアルモードで使われた場合、カーソル桁を
	起点に各行に対して {cmd} を試行し、成功した部分を複数選択に加えます。
	例えば、次のようなバッファを考えます。 >
		fooo
		  bar
		 bazzzz
<
	三行を行指向選択し、カーソルを3桁目か4桁目において {cmd} に |iw| を与
	えると、 "fooo", "bar", "bazzzz" を複数選択に加えます。


  - 基礎メソッド
					*multiselect-Multiselector.append()*
Multiselector.append({item})    [method]
	複数選択要素 {item} を `Multiselector.itemlist` の末尾に加えます。
	{item} は `Item` オブジェクトです。返り値は `Multiselector.itemlist`
	です。
	|multiselect-Multiselector.itemlist|
>
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]

		call s:multiselector.append(itemlist)
		" s:multiselector.itemlist == [item1, item2, item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|


					*multiselect-Multiselector.remove()*
Multiselector.remove({idx}[, {end}])    [method]
Multiselector.remove({indexlist})
	指定された複数選択要素を選択解除し、 `Multiselector.itemlist` から取り
	除きます。
	|multiselect-Multiselector.itemlist|

	{end} を指定しない場合:
	`Multiselector.itemlist` から {idx} 位置の要素を選択解除し、この要素を
	返します。 >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let lastitem = s:multiselector.remove(-1)
		" lastitem is item3
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.append()|

	{end} を指定する場合:
	{idx} から {end} までの要素を選択解除し、この要素からなるリストを返し
	ます。 >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let removeditems = s:multiselector.remove(0, 1)
		" removeditems == [item1, item2]
<
	{idx} と {end} に指定できる値については |list-index| を参照してくださ
	い。

	インデックスのリストを与えた場合は指定の位置の要素を選択解除し、この要
	素からなるリストを返します >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let removed = s:multiselector.remove([0, 2])
		" removed is [item1, item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.append()|


				*multiselect-Multiselector.enumerate()*
Multiselector.enumerate([{Filterexpr}])    [method]
	複数選択要素のインデックスと要素自体のリストを要素に持つリストを返しま
	す。このメソッドは `Multiselector.emit()` と違い選択解除を行いません。
	|multiselect-Multiselector.emit()| >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let list = s:multiselector.enumerate()
		" list == [[0, item1], [1, item2], [2, item3]]
<
	{Filterexpr} は二つの引数を取る関数参照 |Funcref| です。{Filterexpr}
	が与えられた場合、すべての複数選択要素に対して要素のインデックスと要素
	自体を引数にあたえて評価し、{Filterexpr} が真 |TRUE| を返す要素のみを
	返します。 >
		let list = s:multiselector.enumerate(
		         \ {index, item -> item.head[2] != 2})
		" list == [[0, item1], [2, item3]]
<

					*multiselect-Multiselector.itemnum()*
Multiselector.itemnum([{Filterexpr}])    [method]
	現在の複数選択の数を返します。 >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let nr = s:multiselector.itemnum()
		" nr == 3
<
	{Filterexpr} は二つの引数を取る関数参照 |Funcref| です。{Filterexpr}
	が与えられた場合、すべての複数選択要素に対して要素のインデックスと要素
	自体を引数にあたえて評価し、{Filterexpr} が真 |TRUE| を返す要素の数を
	返します。 >
		" 1行目に存在する複数選択の数を返す
		call s:multiselector.itemnum({i, item -> item.head[1] == 1})
<

					*multiselect-Multiselector.isempty()*
Multiselector.isempty()    [method]
	複数選択が存在しなければ真 |TRUE| が、存在すれば偽 |FALSE| が返りま
	す。 >
		call s:multiselector.uncheckall()
		let bool = s:multiselector.isempty()
		" bool is 1

		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let bool = s:multiselector.isempty()
		" bool is 0
<

				*multiselect-Multiselector.lastevent()*
Multiselector.lastevent()    [method]
	最後に行った複数選択の選択・選択解除の情報を返します。情報は以下のキー
	をもつ辞書 |Dictionary| です。
	  event: 最後に行われた操作 "check" か "uncheck" です
	  itemlist: 最後に選択・解除された要素のリストです
>
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let last = s:multiselector.lastevent()
		" last.event ==# 'check'
		" last.itemlist == [item1, item2, item3]

		call s:multiselector.remove(-1)

		let last = s:multiselector.lastevent()
		" last.event ==# 'uncheck'
		" last.itemlist == [item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.append()|
	|multiselect-Multiselector.remove()|


					*multiselect-Multiselector.show()*
Multiselector.show()    [method]
	複数選択要素をすべてハイライトします。

	`Multiselector.quench()` メソッドでハイライトを消さなければ使う必要は
	ありません。 |multiselect-Multiselector.quench()|
>
		" 複数選択をかくす
		call s:multiselector.quench()

		" もう一度ハイライトする
		call s:multiselector.show()
<

					*multiselect-Multiselector.quench()*
Multiselector.quench()    [method]
	複数選択のハイライトをすべて消します。選択を解除するわけではありませ
	ん。 |multiselect-Multiselector.show()| メソッドでもう一度ハイライトで
	きます。
>
		" 複数選択をかくす
		call s:multiselector.quench()

		" もう一度ハイライトする
		call s:multiselector.show()
<

				*multiselect-Multiselector.unsafe_append()*
Multiselector.unsafe_append({item})    [method]
	このメソッドは |multiselect-Multiselector.append()| メソッドのように
	複数選択要素を `Multiselector.itemlist` に加えますが、要素同士の重複
	チェックを省くのでより高速に動作します。ただし、同時に問題を起こす可能
	性もあるので、基本的には |multiselect-Multiselector.append()| メソッド
	を使ってください。 {item} 内の要素に重複がないと確信でき、パフォーマン
	スに問題を抱えている時にのみ使用してください。


  - イベントコントロール
					*multiselect-Multiselector.event()*
Multiselector.event({event})    [method]
	{event} で指定された自動コマンドイベントに紐づけられた `Task` オブジェ
	クトを返します。これは `Multiselector` オブジェクト自身の制御のために
	使われます。 |multiselect-object-Task|

	`Multiselector` オブジェクトの制御のために次の自動コマンドイベントに対
	して `Task` オブジェクトを準備します。
	 |BufLeave|, |TabLeave|, |CmdwinEnter|, |CmdwinLeave|, |TextChanged|,
	|InsertEnter|, |WinNew|

	|BufLeave| イベントで初期化処理が実行されます。すべての複数選択を解除
	し、 |multiselect-Multiselector.bufnr| を -1 に設定します。

	|TabLeave| イベントで初期化処理が実行されます。すべての複数選択を解除
	し、 |multiselect-Multiselector.bufnr| を -1 に設定します。

	|CmdwinEnter| イベントで中断処理が実行されます。今までの複数選択は保存
	され、コマンドラインウィンドウ　|command-line-window| 用の
	`Multiselector.itemlist` に切り替わります。

	|CmdwinLeave| イベントでは初期化処理が走ったのちに復帰処理が実行されま
	す。中断処理で保存された情報を復元します。

	|TextChanged| イベントですべての複数選択を選択解除します。

	|InsertEnter| イベントですべての複数選択を選択解除します。

	新しいウィンドウが開かれ、現在と同じバッファを表示している場合、
	|WinNew| イベントで選択位置ハイライトの同期処理が実行されます。



------------------------------------------------------------------------------
Region オブジェクト~
					*multiselect-object-Region*

`Region` オブジェクトは `Multiselect.Region()` によって得られます。
|multiselect-Multiselect.Region()|

					*multiselect-Region.head*
Region.head    [list]
	そのオブジェクトの表す範囲の先頭位置です。 |setpos()| 関数の引数として
	有効な形式です。 >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call setpos('.', region.head)
		" getpos('.') == head
<

					*multiselect-Region.tail*
Region.tail    [list]
	そのオブジェクトの表す範囲の末尾位置です。 |setpos()| 関数の引数として
	有効な形式です。 >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call setpos('.', region.tail)
		" getpos('.') == tail
<

					*multiselect-Region.type*
Region.type    [string]
	そのオブジェクトの表す範囲の種類を表す文字列です。 "char", "line",
	"block" のどれかで、それぞれ |characterwise-visual|,
	|linewise-visual|, |blockwise-visual| に相当します。


					*multiselect-Region.extended*
Region.extended    [boolean]
	このプロパティはそのオブジェクトが矩形範囲を表すときにのみ意味を持ちま
	す。この値が真 |TRUE| なら、各行の末尾位置は行末へ拡張されます。これは
	|v_$| が使われた場合に相当します。


					*multiselect-Region.select()*
Region.select()    [method]
	そのオブジェクトの表す範囲をビジュアル選択します。
	  - Example: 範囲を削除 >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call region.select()
		normal! d
<
	  これは次の操作とほぼ等しくなります。 >
		normal! v
		call setpos('.', [0, 1, 1, 0])
		normal! o
		call setpos('.', [0, 1, 3, 0])
		normal! d
<
	行単位や矩形範囲についても同様に使用できます。


					*multiselect-Region.yank()*
Region.yank()    [method]
	そのオブジェクトの表す範囲をヤンク |yank| し、その文字列を返します。 >
		call setline(1, 'foo bar baz')
		let head = [0, 1, 5, 0]
		let tail = [0, 1, 7, 0]
		let region = s:Multiselect.Region(head, tail, 'char')
		let text = region.yank()
		echo text   " bar
<

					*multiselect-Region.includes()*
Region.includes({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.includes({lnum})
Region.includes({startlnum}, {endlnum})
Region.includes({region})
	そのオブジェクトが指定された範囲を内包していれば真 |TRUE| が、そうでな
	ければ偽 |FALSE| が返ります。

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.includes([0, 1, 1, 0])
		" bool is FALSE

		let bool = region1.includes([0, 1, 2, 0])
		" bool is TRUE

		let bool = region1.includes(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.includes(region2)
		" bool is FALSE

		let head = [0, 1, 2, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.includes(region3)
		" bool is TRUE
<

					*multiselect-Region.isinside()*
Region.isinside({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.isinside({lnum})
Region.isinside({startlnum}, {endlnum})
Region.isinside({region})
	そのオブジェクトが指定された範囲に内包されていれば真 |TRUE| が、そうで
	なければ偽 |FALSE| が返ります。

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.isinside(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region2)
		" bool is FALSE

		let head = [0, 1, 2, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region3)
		" bool is FALSE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 5, 0]
		let region4 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region4)
		" bool is TRUE
<

					*multiselect-Region.touches()*
Region.touches({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.touches({lnum})
Region.touches({startlnum}, {endlnum})
Region.touches({region})
	そのオブジェクトが指定された範囲に触れていれば真 |TRUE| が、そうでなけ
	れば偽 |FALSE| が返ります。

	引数は `Multiselect.Region()` と共通です。
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.touches([0, 1, 1, 0])
		" bool is FALSE

		let bool = region1.touches([0, 1, 2, 0])
		" bool is TRUE

		let bool = region1.touches([0, 1, 4, 0])
		" bool is TRUE

		let bool = region1.touches([0, 1, 5, 0])
		" bool is FALSE

		let bool = region1.touches(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 2, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region2)
		" bool is FALSE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region3)
		" bool is TRUE

		let head = [0, 1, 4, 0]
		let tail = [0, 1, 6, 0]
		let region4 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region4)
		" bool is TRUE

		let head = [0, 1, 5, 0]
		let tail = [0, 1, 6, 0]
		let region5 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region5)
		" bool is FALSE
<


------------------------------------------------------------------------------
Item オブジェクト~
					*multiselect-object-Item*

`Item` オブジェクトは `Multiselect.Item()` によって得られます。
|multiselect-Multiselect.Item()|

`Item` オブジェクトは `Region` オブジェクトのすべてのプロパティを継承していま
す。

					*multiselect-Item.id*
Item.id    [number]
	各オブジェクトに特有の数字です。


					*multiselect-Item.bufnr*
Item.bufnr    [number]
	そのオブジェクトの所属するバッファ番号です。


					*multiselect-Item.head*
Item.head    [list]
	|multiselect-Region.head| をご覧ください。


					*multiselect-Item.tail*
Item.tail    [list]
	|multiselect-Region.tail| をご覧ください。


					*multiselect-Item.type*
Item.type    [string]
	|multiselect-Region.type| をご覧ください。


					*multiselect-Item.extended*
Item.extended    [boolean]
	|multiselect-Region.extended| をご覧ください。


					*multiselect-Item.select()*
Item.select()    [method]
	|multiselect-Region.select()| をご覧ください。


					*multiselect-Item.yank()*
Item.yank()    [method]
	|multiselect-Region.yank()| をご覧ください。


					*multiselect-Item.includes()*
Item.includes()    [method]
	|multiselect-Region.includes()| をご覧ください。


					*multiselect-Item.isinside()*
Item.isinside()    [method]
	|multiselect-Region.isinside()| をご覧ください。


					*multiselect-Item.touches()*
Item.touches()    [method]
	|multiselect-Region.touches()| をご覧ください。


					*multiselect-Item.show()*
Item.show({higroup})    [method]
	ハイライトグループ {higroup} でバッファ上の該当位置をハイライトしま
	す。 |highlight-groups|


					*multiselect-Item.quench()*
Item.quench()    [method]
	バッファ上の該当位置をハイライトを消します。


					*multiselect-Item.isshownin()*
Item.isshownin([{winid}])    [method]
	ウィンドウid {winid} によって指定されるウィンドウにそのオブジェクトの
	ハイライトが存在すれば真 |TRUE| が、そうでなければ偽 |FALSE| が返りま
	す。 {winid} は |win_getid()| 関数によって取得できます。 {winid} が省
	略された場合はカレントウィンドウの情報が返ります。



------------------------------------------------------------------------------
Change オブジェクト~
					*multiselect-object-Change*

`Change` オブジェクトはバッファを編集した場合の、バッファ上のある位置の移動を
追跡するために使われます。これは必須ではありませんが、プラグインを作る際に便利
かもしれません。


					*multiselect-Change.beforedelete()*
Change.beforedelete({head}[, {tail}[, {type}[, {extended}]]])    [method]
Change.beforedelete({lnum})
Change.beforedelete({startlnum}, {endlnum})
Change.beforedelete({region})
	このメソッドはバッファ編集の直前に呼ぶ必要があります。引数には削除しよ
	うとしている範囲を与えてください。これは |inclusive| な削除範囲とみな
	されます、すなわち {tail} は削除の対象に含まれます。

	このメソッドはオブジェクト自身を返します。


					*multiselect-Change.afterinsert()*
Change.afterinsert({head}[, {tail}[, {type}[, {extended}]]])    [method]
Change.afterinsert({lnum})
Change.afterinsert({startlnum}, {endlnum})
Change.afterinsert({region})
	このメソッドはバッファ編集の直後に呼ぶ必要があります。引数には挿入した
	文字列の範囲を指定してください。{tail} は挿入文字列の終端 (= 続く文字
	列の開始位置) です。

	このメソッドはオブジェクト自身を返します。


					*multiselect-Change.apply()*
Change.apply({pos})    [method]
Change.apply({region})
	{pos} あるいは {region} の編集後の位置を計算します。{pos}, {region} は
	破壊的 (in-place) 変更を受けます。

	NOTE: `Change.apply()` は大量の対象を処理する場合、あまり効率的ではあ
	       りません。 `Change.mapapply()` の使用を検討してください。
	      |multiselect-Change.mapapply()|


					*multiselect-Change.mapapply()*
Change.mapapply({itemlist})    [method]
	このメソッドは次の操作と同じ結果を返します。 >
		call map({itemlist}, 'change.apply(v:val)')
<
	ただし、 {itemlist} の要素数が多いときより効率的に結果を得られます。
	{itemlist} の要素は位置を表すリストか、 `Region` オブジェクトでなけれ
	ばいけません。


  - 使用方法
次のようなバッファがあるとします >
	foo bar baz
<
例えば、現在のカーソル位置を追跡するとしましょう。まず、追跡する位置を保存しま
す。 >
	let curpos = getpos('.')
<
カーソルは "baz" の 'z' にあったとします。これから "bar" を削除して "x" を挿入
した後の位置の移動を計算します。
まず、削除前に `Change.beforedelete()` を呼びます。 >
	let bar = s:Multiselect.Region([0, 1, 5, 0], [0, 1, 7, 0], 'char')
	let change = s:Multiselect.Change()
	call change.beforedelete(bar)
<
バッファを編集します。 >
	call bar.select()
	normal! cx
<
今、バッファはこのようになっています。 >
	foo x baz
<
文字の挿入後には `Change.afterinsert()` を呼びます。 |`[| マークがそのまま使え
ます。 >
	call change.afterinsert(getpos("'["), getpos("']"), 'char')
<
準備は整いました。 `Change.apply()` メソッドで編集後の位置を計算しましょう。 >
	call change.apply(curpos)
	" curpos == [0, 1, 9, 0]
<
|setpos()| 関数で編集後のカーソル位置へ移動できます。 >
	call setpos('.', curpos)
<


------------------------------------------------------------------------------
NeatTask オブジェクト~
					*multiselect-object-NeatTask*

`NeatTask` オブジェクトはいくつかの処理をまとめておいて、後ほど一度に実行する
ために使われます。処理は |multiselect-NeatTask.call()|,
|multiselect-NeatTask.execute()|, |multiselect-NeatTask.append()| を使って登録
できます。 >
	function! s:sayfoo() abort
	  echo 'foo'
	endfunction

	let task = s:Multiselect.NeatTask()
	call task.call(function('s:sayfoo'), [])
	call task.execute('echo "foo"')
<

登録しておいた処理は |multiselect-NeatTask.trigger()| を使って実行します。処理
は登録した順番で実行されます。 >
	call task.trigger()
<

|multiselect-NeatTask.repeat()| を使うことで実行回数を制限できます。設定された
実行回数を超えると |multiselect-NeatTask.trigger()| は何も実行しなくなります。
デフォルトの回数は 1 です。 >
	let neattask = s:Multiselect.NeatTask()
	call neattask.execute('echo "foo"').repeat(1)

	" 'foo' を出力
	call neattask.trigger()

	" 何もしない
	call neattask.trigger()
<

`NeatTask` は内部スイッチをもち、 |multiselect-NeatTask.skip()| メソッドによっ
て一次的に機能停止できます。 >
	let neattask = s:Multiselect.NeatTask()
	call neattask.execute('echo "foo"').skip(1)

	" 何もしない
	call neattask.trigger()

	" 'foo' を出力
	call neattask.trigger()
<

					*multiselect-NeatTask.call()*
NeatTask.call({Funcref}, {args}[, {dict}])    [method]
	リスト |List| {args} の要素を引数として関数参照 {Funcref} の指す関数を
	呼ぶタスクを登録します。 {dict} は "dict" 属性つきの関数用で、これがロ
	ーカル変数 "self" に代入されます。 |Dictionary-function|
	このメソッドはオブジェクト自身を返します。
>
		function! s:sayfoo() abort
		    echo 'foo'
		endfunction

		" 新しいタスクの生成
		let neattask = s:Multiselect.NeatTask()
		call neattask.call(function('s:sayfoo'), [])

		" 実行
		call task.trigger()
<

					*multiselect-NeatTask.execute()*
NeatTask.execute({cmd})    [method]
	Ex コマンド {cmd} を実行するタスクを登録します。
	このメソッドはオブジェクト自身を返します。 >
		" 新しいタスクの生成
		let neattask = s:Multiselect.NeatTask().execute('echo "foo"')

		" 実行
		call task.trigger()
<

					*multiselect-NeatTask.append()*
NeatTask.append({task})    [method]
	他のタスクオブジェクト {task} を即時実行するタスクを登録します。
	{task} は `NeatTask` オブジェクトか `Task` オブジェクトでなければいけ
	ません。このメソッドはオブジェクト自身を返します。 >
		" 新しいタスクの生成
		let task = s:Multiselect.NeatTask().execute('echo "foo"')
		let neattask = s:Multiselect.NeatTask().append(task)

		" 実行
		call neattask.trigger()
<

					*multiselect-NeatTask.trigger()*
NeatTask.trigger([{forcibly}])    [method]
	登録されたタスクを実行します。
	このメソッドはオブジェクト自身を返します。

	{forcibly} があたえられ、それが真 |TRUE| なら、設定された実行回数を超
	えていても処理を実行します。
	|multiselect-NeatTask.hasdone()|


					*multiselect-NeatTask.clear()*
NeatTask.clear()    [method]
	登録されたタスクをすべて除去します。
	このメソッドはオブジェクト自身を返します。


					*multiselect-NeatTask.clone()*
NeatTask.clone()    [method]
	自身のクローンを生成します。クローンは別のオブジェクトですが同じ登録タ
	スクを持っています。


					*multiselect-NeatTask.isactive()*
NeatTask.isactive()    [method]
	自身が実行可能なら |TRUE| を返します。 |multiselect-NeatTask.skip()|
	で一時的に停止されていれば偽 |FALSE| を返します。


					*multiselect-NeatTask.skip()*
NeatTask.skip([{count}])    [method]
	次の {count} 回、 |multiselect-NeatTask.trigger()| が呼ばれても処理が
	実行されなくなります。 {count} が省略されれば 1 回スキップします。
	{count} が 0 なら再び実行されるようになります。
	このメソッドはオブジェクト自身を返します。 >
		let neattask = s:Multiselect.NeatTask()
		call neattask.execute('echo "foo"').skip(1)

		" 何もしない
		call neattask.trigger()

		" 'foo' を出力
		call neattask.trigger()
<


					*multiselect-NeatTask.skipif()*
NeatTask.skipif({Funcref}, {args}[, {dict}])    [method]
	処理の実行をスキップする条件を設定します。 {Funcref} に {args} が渡さ
	れて評価された結果、真 |TRUE| を返した場合は実行をスキップします。
	{dict} は "dict" 属性つきの関数用で、これがローカル変数 "self" に代入
	されます。 |Dictionary-function|
	このメソッドはオブジェクト自身を返します。 >
		let neattask = s:Multiselect.NeatTask()
		call neattask.execute('echo foo').repeat(-1)
		call neattask.skipif({-> g:skip == 1}, [])

		" echo 'foo'
		let g:skip = 0
		call neattask.trigger()

		" does nothing
		let g:skip = 1
		call neattask.trigger()

		" echo 'foo'
		let g:skip = 2
		call neattask.trigger()
<
	設定できる条件は一つだけです。


					*multiselect-NeatTask.repeat()*
NeatTask.repeat([{count}])    [method]
	{count} 回の実行の後、処理が実行されなくなります。 {count} が負の
	場合、回数に制限がなくなります。 `NeatTask` の場合、デフォルトでは 1
	になっており、一回の実行ののち終了します。 {count} が省略された場合、
	今までの実行回数はリセットされ、再び最後に設定された {count} が始まり
	ます。 >
		" 'foo' が三回だけ出力される
		let neattask = s:Multiselect.NeatTask()
					   \.execute('echo "foo"')
					   \.repeat(3)

		call neattask.trigger()
		call neattask.trigger()
		call neattask.trigger()
		call neattask.trigger() " 何も起こらない
<
	このメソッドはオブジェクト自身を返します。


					*multiselect-NeatTask.leftcount()*
NeatTask.leftcount()    [method]
	残りの実行回数を返します。 |multiselect-NeatTask.repeat()| をご覧くだ
	さい。


					*multiselect-NeatTask.hasdone()*
NeatTask.hasdone()    [method]
	|multiselect-NeatTask.repeat()| によって設定された実行回数終了後には真
	|TRUE| が返ります。それ以外では偽が返ります。


					*multiselect-NeatTask.finishif()*
NeatTask.finishif({Funcref}, {args}[, {dict}])    [method]
	タスクの終了条件を設定します。 {Funcref} に {args} が渡されて評価され
	た結果、真 |TRUE| を返した場合タスクを終了します。
	{dict} は "dict" 属性つきの関数用で、これがローカル変数 "self" に代入
	されます。 |Dictionary-function|
	このメソッドはオブジェクト自身を返します。 >
		let neattask = s:Multiselect.NeatTask()
		call neattask.execute('echo foo').repeat(-1)
		call neattask.finishif({-> g:finish == 1}, [])

		" echo 'foo'
		let g:finish = 0
		call neattask.trigger()

		" does nothing
		let g:finish = 1
		call neattask.trigger()
<
	設定できる条件は一つだけです。



------------------------------------------------------------------------------
Task オブジェクト~
					*multiselect-object-Task*

`Task` は自動コマンドイベントや、タイマーなど複数のトリガーによって遅延実行さ
れるタスクです。

`Task` オブジェクトは `NeatTask` のプロパティを継承しています。
|multiselect-object-NeatTask|

`Task` オブジェクトは `NeatTask` オブジェクトのメソッドに加え、
|multiselect-Task.waitfor()|, |multiselect-Task.cancel()| メソッドを持ちます。

`Task` は設定されたトリガーのうちどれかが発火した時に処理を実行します。
デフォルトでは一度処理を実行したのちに破棄されます。実行回数は
|multiselect-Task.repeat()| メソッドで変更できます。


					*multiselect-Task.waitfor()*
Task.waitfor({triggers})    [method]
	オブジェクトにトリガーを設定し、どれかが発火するのを待ちます。
	{triggerlist} はトリガー名のリスト |List| で、以下のいずれかに当てはま
	っていなければいけません。

	  * 文字列 |String|:
	      自動コマンドイベント名 |autocmd-events|とみなされます。
	      |:autocmd| コマンドにおける {pat} には "*" がつかわれます。
	  * リスト |List|:
	      [{event}, {pat}] のように自動コマンドイベント {event}
	      |autocmd-events|とファイルパターン {pat} |autocmd-patterns| の
	      二要素と解釈されます。
	  * 整数 |Number|:
	      タイマーの待機時間 {time} と解釈されます。 |timer|
>
		let task = s:Multiselect.Task().execute('echo "foo"')
		call task.waitfor(['TextChanged', 100])
<
	このメソッドはオブジェクト自身を返しますが、 {triggerlist} が有効な
	要素を含まない場合、空の辞書 |Dictionary| を返します。


					*multiselect-Task.cancel()*
Task.cancel()    [method]
	タスクを停止します。このメソッドはオブジェクト自身を返します。


					*multiselect-Task.call()*
Task.call({Funcref}, {args}[, {dict}])    [method]
	|multiselect-NeatTask.call()| をご覧ください。


					*multiselect-Task.execute()*
Task.execute({cmd})    [method]
	|multiselect-NeatTask.execute()| をご覧ください。


					*multiselect-Task.append()*
Task.append({task})    [method]
	|multiselect-NeatTask.append()| をご覧ください。


					*multiselect-Task.trigger()*
Task.trigger([{forcibly}])    [method]
	|multiselect-NeatTask.trigger()| をご覧ください。


					*multiselect-Task.clear()*
Task.clear()    [method]
	|multiselect-NeatTask.clear()| をご覧ください。


					*multiselect-Task.isactive()*
Task.isactive()    [method]
	|multiselect-NeatTask.isactive()| をご覧ください。


					*multiselect-Task.skip()*
Task.skip([{count}])    [method]
	|multiselect-NeatTask.skip()| をご覧ください。


					*multiselect-Task.skipif()*
Task.skipif({Funcref}, {args}[, {dict}])    [method]
	|multiselect-NeatTask.skipif()| をご覧ください。


					*multiselect-Task.repeat()*
Task.repeat([{count}])    [method]
	|multiselect-NeatTask.repeat()| をご覧ください。


					*multiselect-Task.leftcount()*
Task.leftcount()    [method]
	|multiselect-NeatTask.leftcount()| をご覧ください。


					*multiselect-Task.hasdone()*
Task.hasdone()    [method]
	|multiselect-NeatTask.hasdone()| をご覧ください。


					*multiselect-Task.finishif()*
Task.finishif({Funcref}, {args}[, {dict}])    [method]
	|multiselect-NeatTask.finishif()| をご覧ください。



------------------------------------------------------------------------------
TaskChain オブジェクト~
					*multiselect-object-TaskChain*

`TaskChain` オブジェクトは自動コマンドやタイマーによって順番に実行される数珠つ
なぎの処理を作るために使われます。

|multiselect-TaskChain.hook()| メソッドによってトリガーの流れをつくります。
それぞれのメソッドは紐づけられた `NeatTask` オブジェクトを返すので、このインス
タンスに処理を登録すれば、順番に実行されます。紐づけられたタスクが終了し次第、
次のトリガーを待つ状態に移行します。 >
	let taskchain = s:Multiselect.TaskChain()
	let task1 = taskchain.hook(['InsertLeave'])
	let task2 = taskchain.hook(['CursorMoved'])
	call task2.execute('echo "foo"')
	call taskchain.waitfor()
<
この例ではインサートモードを抜けた後、カーソルを移動したときに "foo" と表示し
ます。これは次のようにより短く書けます。 >
	let taskchain = s:Multiselect.TaskChain()
	call taskchain.hook(['InsertLeave'])
	call taskchain.hook(['CursorMoved']).execute('echo "foo"')
	call taskchain.waitfor()
<

					*multiselect-TaskChain.hook()*
TaskChain.hook({triggerlist})    [method]
	自動コマンドあるいは遅延時間のどれかによるトリガーを予約します。
	{triggerlist} はトリガー名のリスト |List| で、以下のいずれかに当てはま
	っていなければいけません。

	  * 文字列 |String|:
	      自動コマンドイベント名 |autocmd-events|とみなされます。
	      |:autocmd| コマンドにおける {pat} には "*" がつかわれます。
	  * リスト |List|:
	      [{event}, {pat}] のように自動コマンドイベント {event}
	      |autocmd-events|とファイルパターン {pat} |autocmd-patterns| の
	      二要素と解釈されます。
	  * 整数 |Number|:
	      タイマーの待機時間 {time} と解釈されます。 |timer|

	このメソッドは `NeatTask` オブジェクトを返します。この `NeatTask` イン
	スタンスに処理を設定することでいずれかのトリガー発火時に処理を実行でき
	ます。
>
		let taskchain = s:Multiselect.TaskChain()
		let task1 = taskchain.hook(['CmdwinLeave'])
		let task2 = taskchain.hook(['CursorMoved', 1000])
		call task2.execute('echo "original buffer"')
		call taskchain.waitfor()
<
	コマンドラインウィンドウ |cmdline-window| を抜けた後、カーソルを動かす
	か、一秒経過するかすると "original buffer" というメッセージが表示され
	ます。
	|multiselect-object-NeatTask|
	|multiselect-NeatTask.repeat()|


					*multiselect-TaskChain.trigger()*
TaskChain.trigger()    [method]
	現在トリガーを待っている処理を発火し、次のトリガーを待ちます。
	このメソッドはオブジェクト自身を返します。


					*multiselect-TaskChain.waitfor()*
TaskChain.waitfor()    [method]
	タスクチェインを開始し、最初のトリガーを待ちます。


					*multiselect-TaskChain.cancel()*
TaskChain.cancel()    [method]
	タスクチェインを停止します。


					*multiselect-TaskChain.repeat()*
TaskChain.repeat()    [method]
	タスクチェインの実行回数を設定します。デフォルト値は 1 です。


					*multiselect-TaskChain.leftcount()*
TaskChain.leftcount()    [method]
	残りの実行回数を返します。|multiselect-TaskChain.repeat()| をご覧くだ
	さい。


					*multiselect-TaskChain.hasdone()*
TaskChain.hasdone()    [method]
	タスクチェインに設定された実行回数が終了していれば真 |TRUE| を、そうで
	なければ偽 |FALSE| を返します。


					*multiselect-TaskChain.finishif()*
TaskChain.finishif({Funcref}, {args}[, {dict}])    [method]
	|multiselect-NeatTask.finishif()| をご覧ください。



==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet::fdl=0:fen:fdm=marker:noet:
