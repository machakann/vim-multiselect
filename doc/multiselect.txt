*multiselect.txt*	A library for multiple selection
						Last change:08-Mar-2018.

Author  : machakann <https://github.com/machakann>
License : MIT license
Copyright (c) 2017 Masaaki Nakamura {{{

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
}}}

Requirement:	Vim 8.0 or higher

==============================================================================
INDEX					*multiselect-index*

INTRODUCTION				|multiselect-introduction|
KEYMAPPINGS				|multiselect-keymappings|
HIGHLIGHT GROUPS			|multiselect-higroups|
AUTOCMD EVENTS				|multiselect-events|
HOW TO MAKE A PLUGIN			|multiselect-howtomakeaplugin|
API					|multiselect-api|

==============================================================================
INTRODUCTION				*multiselect-introduction*

*multiselect.vim* is a library to handle multiple selection areas in Vim text
editor. The multiple selection areas follow the basic rules listed below:

	1. Two selections cannot overlap. The newer one removes the old one.
	2. These areas are quenched if the current buffer is changed.
	3. These areas are quenched if the cursor moved to another buffer.
	4. These areas are quenched if the cursor moved to another |tabpage|.

This plugin only serves functions to select/unselect multiple visual selection
areas. |multiselect-keymappings| 

The further features are supplied by other plugins. The other plugins can
communicate with this plugin through the provided Application Programming
Interfaces (API). |multiselect-api|

==============================================================================
KEYMAPPINGS				*multiselect-keymappings*

The following keymappings are available with |:nmap| and |:xmap|.

<Plug>(multiselect-check)		*<Plug>(multiselect-check)*
	This keymapping registers a current visual selection area as a
	multiple selection area. In normal mode, it registers a |word| under
	the cursor.


<Plug>(multiselect-checksearched)	*<Plug>(multiselect-checksearched)*
	This keymapping registers the texts matching with the last searched
	patten |@/|. In normal mode, it registers all the matched texts in the
	current buffer. In visual mode, it registers the matched pattern in
	the visual-selected range.

	NOTE: The following keymapping registers all texts matching with the
	      word under the cursor.
>
	nmap <Space>v *N<Plug>(multiselect-checksearched)
<

<Plug>(multiselect-uncheck)		*<Plug>(multiselect-uncheck)*
	This keymapping deletes registered multiselect items. In normal mode,
	it deletes an item under the cursor. In visual mode, it deletes
	registered items in the current visual-selected range.


<Plug>(multiselect-uncheckall)		*<Plug>(multiselect-uncheckall)*
	This keymapping deletes all registered items.


<Plug>(multiselect-undo)		*<Plug>(multiselect-undo)*
	This keymapping rollback the last action.


[count]<Plug>(multiselect-next)		*<Plug>(multiselect-next)*
	This keymapping move cursor to the next multiselect item.


[count]<Plug>(multiselect-previous)	*<Plug>(multiselect-previous)*
	This keymapping move cursor to the previous multiselect item.


<Plug>(multiselect)			*<Plug>(multiselect)*
	This is a bit complex but could be a useful keymapping.

	|Normal| mode: This keymapping selects texts matching with the |word|
	under the cursor. If the cursor is on a multiselection, only the texts
	inside the region will be selected.

	|characterwise-visual| mode:
	If the visual selection includes one or more multiselection, this
	keymapping removes the items outside the visual selection.

	If the visual selection is included in a multiselection, this
	keymapping multi-selects texts matching with the selected string
	inside the original multiselection.

	Otherwise this keymapping multi-selects texts matching with the
	selected string over the current buffer.

	|linewise-visual| or |blockwise-visual| mode:
	If the visual selection includes one or more multiselection, this
	keymapping removes the items outside the visual selection.

	Otherwise, this keymapping selects the selection region.


					*multiselect-broadcasting-textobject*
Broadcasting textobjects~

The following textobjects behave as same as those original textobjects,
except in |linewise| visual mode. In that mode, a broadcasting textobject
tries itself for each line at the cursor column to multiselect. It is like
|blockwise-visual| mode but it does not requires strict block shaped targets.
For example, `<Plug>(multiselect-iw)` can select "foo", "bar" and "baz" in the
following case.
>
	foo
	 bar
	  baz
<
NOTE: These keymappings has a known bug. If the target of textobject is a
      character, this target may not be selected. The "a" at the second line
      may not be selected. >
	foo
	  a
	  baz
<
Use |:xmap| to map them.
>
	xmap iw <Plug>(multiselect-iw)
<

<Plug>(multiselect-iw)			*<Plug>(multiselect-iw)*
	The broadcasting textobject of |iw|.

<Plug>(multiselect-aw)			*<Plug>(multiselect-aw)*
	The broadcasting textobject of |aw|.

<Plug>(multiselect-iW)			*<Plug>(multiselect-iW)*
	The broadcasting textobject of |iW|.

<Plug>(multiselect-aW)			*<Plug>(multiselect-aW)*
	The broadcasting textobject of |aW|.

<Plug>(multiselect-i')			*<Plug>(multiselect-i')*
	The broadcasting textobject of |i'|.

<Plug>(multiselect-a')			*<Plug>(multiselect-a')*
	The broadcasting textobject of |a'|.

<Plug>(multiselect-i")			*<Plug>(multiselect-iquote)*
	The broadcasting textobject of |iquote|.

<Plug>(multiselect-a")			*<Plug>(multiselect-aquote)*
	The broadcasting textobject of |aquote|.

<Plug>(multiselect-i`)			*<Plug>(multiselect-i`)*
	The broadcasting textobject of |i`|.

<Plug>(multiselect-a`)			*<Plug>(multiselect-a`)*
	The broadcasting textobject of |a`|.

<Plug>(multiselect-i()			*<Plug>(multiselect-i()*
	The broadcasting textobject of |i(|.

<Plug>(multiselect-a()			*<Plug>(multiselect-a()*
	The broadcasting textobject of |a(|.

<Plug>(multiselect-i[)			*<Plug>(multiselect-i[)*
	The broadcasting textobject of |i[|.

<Plug>(multiselect-a[)			*<Plug>(multiselect-a[)*
	The broadcasting textobject of |a[|.

<Plug>(multiselect-i{)			*<Plug>(multiselect-i{)*
	The broadcasting textobject of |i{|.

<Plug>(multiselect-a{)			*<Plug>(multiselect-a{)*
	The broadcasting textobject of |a{|.

<Plug>(multiselect-it)			*<Plug>(multiselect-it)*
	The broadcasting textobject of |it|.

<Plug>(multiselect-at)			*<Plug>(multiselect-at)*
	The broadcasting textobject of |at|.


==============================================================================
HIGHLIGHT GROUPS			*multiselect-higroups*

The multiselect items on a buffer will be highlighted like |Visual| selection.
The color of the highlight can be customized through the highlight groups.

MultiselectItem				*hl-MultiselectItem*
	The highlight group for a region of multiselect item. It is linked to
	|hl-VisualNOS| in default. >
		highlight default link MultiselectItem VisualNOS
<
	If |hl-VisualNOS| does not exist, it is linked to |hl-Visual|. >
		highlight default link MultiselectItem Visual
<
	The highlight color can be optimized by |:highlight| command. >
		highlight MultiselectItem ctermfg=White ctermbg=Red
		                               \ guifg=White   guibg=Red
<

==============================================================================
AUTOCMD EVENTS				*multiselect-events*

MultiselectEnter			*MultiselectEnter*
	This autocmd event is triggered once when the `Multiselector` instance
	is born.


MultiselectCheckPost			*MultiselectCheckPost*
	This autocmd event is triggered when any multiselect item is added.
>
		autocmd User MultiselectCheckPost echom 'Check!'
<
	`Multiselector.lastevent()` method returns the selected items.
	|multiselect-Multiselector.lastevent()|


MultiselectUncheckPost			*MultiselectUncheckPost*
	This autocmd event is triggered when any multiselect item is removed.
>
		autocmd User MultiselectUncheckPost echom 'Uncheck!'
<
	`Multiselect.lastevent()` method returns the unselected items.
	|multiselect-Multiselector.lastevent()|


==============================================================================
HOW TO MAKE A PLUGIN			*multiselect-howtomakeaplugin*

Anyone can make a new plugin utilizing this plugin. Here, let's make a plugin
which edit multiple selected texts converting to "foo", to learn how to use
the available API. This is, of course, nothing useful, but taking a glance of
the following processes may be helpful to start communicating with the APIs.
See the next |multiselect-api| section also.

Step 0~
Read |write-plugin| and prepare a plugin file: >
	~/.vim/plugin/fooize.vim
<
Although we will write everything this tiny plugin into it, if you make your
new plugin, it would be better to think the use of |autoload| scripts.



Step 1~
The first thing to do is to load the `Multiselect` module and to obtain an
`Multiselector` instance.
>
	" Multiselect module
	let s:Multiselect = multiselect#import()
<
This module contains some functions, constructors and constants, but in many
cases what you need would be only the `Multiselect.load()` function. This
function returns the `Multiselector` instance.
>
	" Multiselector instance
	let s:multiselector = s:Multiselect.load()
<
Use this instance to get information and to control the multiple selections.



Step 2~
Next, user may already have some selections, then get the positions of the
selections. Use `Multiselector.emit()` method to get all the items. The
"emitted" items are no longer selected.
>
	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif
	endfunction
<
Process each item one-by-one. An item of selection have a useful method to
re-select its range `Item.select()`. Use this method to re-select and edit it.

It is worth noting that items should be edited from the end of a buffer to the
beginning of a buffer. Because if an item was edited, it might changes the
position of the following items. It may cause a complete mess on the buffer.
Simply use `Multiselector.sort()` method and |reverse()| it to avoid the
positional confusions. >
	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  for item in reverse(itemlist)
	    call item.select()
	    normal! cfoo
	  endfor
	endfunction
<
In case you want to insert a text into a buffer, the auto-indent may also
cause the positional confusions. Unfortunately, this is difficult to avoid but
it is possible to minimize the risk to set 'indentkeys' (or 'cinkeys') as its
default. |multiselect-Multiselect.shiftenv()| and
|multiselect-Multiselect.restoreenv()| are useful to do this.
>
	let s:shiftenv = s:Multiselect.shiftenv
	let s:restoreenv = s:Multiselect.restoreenv

	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  let env = s:shiftenv()
	  try
	    for item in reverse(itemlist)
	      call item.select()
	      normal! cfoo
	    endfor
	  finally
	    call s:restoreenv(env)
	  endtry
	endfunction
<


Step 3~
The final step is to implement the interface to users. Here, we will implement
a command and a |Normal| mode keymapping.
>
	command! Fooize call Fooize()
	nnoremap <silent> <Space>f :<C-u>call Fooize()<CR>
<

The resulted plugin is:
>
	if exists("g:loaded_fooize")
	  finish
	endif
	let g:loaded_fooize = 1

	let s:Multiselect = multiselect#import()
	let s:multiselector = s:Multiselect.load()
	let s:shiftenv = s:Multiselect.shiftenv
	let s:restoreenv = s:Multiselect.restoreenv

	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  let env = s:shiftenv()
	  try
	    for item in reverse(itemlist)
	      call item.select()
	      normal! cfoo
	    endfor
	  finally
	    call s:restoreenv(env)
	  endtry
	endfunction

	command! Fooize call Fooize()
	nnoremap <silent> <Space>f :<C-u>call Fooize()<CR>
<
This file is in `macros/multiselect/demo/fooize.vim`.

==============================================================================
API					*multiselect-api*

List of contents~

* Multiselect module~
  Multiselect			|multiselect-module-Multiselect|
  multiselect#import()		|multiselect#import()|

  Multiselect.DEFAULTHIGROUP	|multiselect-Multiselect.DEFAULTHIGROUP|
  Multiselect.load()		|multiselect-Multiselect.load()|

  - class constructors
  Multiselect.Region()		|multiselect-Multiselect.Region()|
  Multiselect.Item()		|multiselect-Multiselect.Item()|
  Multiselect.Change()		|multiselect-Multiselect.Change()|
  Multiselect.EventTask()	|multiselect-Multiselect.EventTask()|
  Multiselect.TimerTask()	|multiselect-Multiselect.TimerTask()|
  Multiselect.Task()	|multiselect-Multiselect.Task()|
  Multiselect.TaskChain()	|multiselect-Multiselect.TaskChain()|

  - utility functions
  Multiselect.shiftenv()	|multiselect-Multiselect.shiftenv()|
  Multiselect.restoreenv()	|multiselect-Multiselect.restoreenv()|
  Multiselect.str2type()	|multiselect-Multiselect.str2type()|
  Multiselect.str2visualcmd()	|multiselect-Multiselect.str2visualcmd()|
  Multiselect.inorderof()	|multiselect-Multiselect.inorderof()|
  Multiselect.inbetween()	|multiselect-Multiselect.inbetween()|
  Multiselect.isextended()	|multiselect-Multiselect.isextended()|

* Multiselector class~
  Multiselector			|multiselect-class-Multiselector|

  - members
  Multiselector.name		|multiselect-Multiselector.name|
  Multiselector.bufnr		|multiselect-Multiselector.bufnr|
  Multiselector.higroup		|multiselect-Multiselector.higroup|
  Multiselector.itemlist	|multiselect-Multiselector.itemlist|

  - main interfaces
  Multiselector.check()		|multiselect-Multiselector.check()|
  Multiselector.checkpattern()	|multiselect-Multiselector.checkpattern()|
  Multiselector.uncheck()	|multiselect-Multiselector.uncheck()|
  Multiselector.uncheckall()	|multiselect-Multiselector.uncheckall()|
  Multiselector.emit()		|multiselect-Multiselector.emit()|
  Multiselector.emit_inside()	|multiselect-Multiselector.emit_inside()|
  Multiselector.emit_touching()	|multiselect-Multiselector.emit_touching()|
  Multiselector.filter()	|multiselect-Multiselector.filter()|
  Multiselector.sort()		|multiselect-Multiselector.sort()|

  - keymap interfaces
  Multiselector.keymap_check()
			     |multiselect-Multiselector.keymap_check()|
  Multiselector.keymap_checkpattern()
			     |multiselect-Multiselector.keymap_checkpattern()|
  Multiselector.keymap_uncheck()
			     |multiselect-Multiselector.keymap_uncheck()|
  Multiselector.keymap_uncheckall()
			     |multiselect-Multiselector.keymap_uncheckall()|
  Multiselector.keymap_undo()
			     |multiselect-Multiselector.keymap_undo()|
  Multiselector.keymap_multiselect()
			     |multiselect-Multiselector.keymap_multiselect()|
  Multiselector.keymap_broadcast()
			     |multiselect-Multiselector.keymap_broadcast()|

  - low-level interfaces
  Multiselector.append()	|multiselect-Multiselector.append()|
  Multiselector.remove()	|multiselect-Multiselector.remove()|
  Multiselector.enumerate()	|multiselect-Multiselector.enumerate()|
  Multiselector.itemnum()	|multiselect-Multiselector.itemnum()|
  Multiselector.isempty()	|multiselect-Multiselector.isempty()|
  Multiselector.lastevent()	|multiselect-Multiselector.lastevent()|
  Multiselector.show()		|multiselect-Multiselector.show()|
  Multiselector.quench()	|multiselect-Multiselector.quench()|
  Multiselector.unsafe_append()	|multiselect-Multiselector.unsafe_append()|

  - event controls
  Multiselector.event()		|multiselect-Multiselector.event()|

* Region class~
  Region			|multiselect-class-Region|
  Region.head			|multiselect-Region.head|
  Region.tail			|multiselect-Region.tail|
  Region.type			|multiselect-Region.type|
  Region.extended		|multiselect-Region.extended|
  Region.select()		|multiselect-Region.select()|
  Region.yank()			|multiselect-Region.yank()|
  Region.includes()		|multiselect-Region.includes()|
  Region.isinside()		|multiselect-Region.isinside()|
  Region.touches()		|multiselect-Region.touches()|

* Item class~
  Item				|multiselect-class-Item|
  Item.id			|multiselect-Item.id|
  Item.bufnr			|multiselect-Item.bufnr|
  Item.head			|multiselect-Item.head|
  Item.tail			|multiselect-Item.tail|
  Item.type			|multiselect-Item.type|
  Item.extended			|multiselect-Item.extended|
  Item.select()			|multiselect-Item.select()|
  Item.yank()			|multiselect-Item.yank()|
  Item.includes()		|multiselect-Item.includes()|
  Item.isinside()		|multiselect-Item.isinside()|
  Item.touches()		|multiselect-Item.touches()|
  Item.show()			|multiselect-Item.show()|
  Item.quench()			|multiselect-Item.quench()|
  Item.isshownin()		|multiselect-Item.isshownin()|

* Change class~
  Change			|multiselect-class-Change|
  Change.beforedelete()		|multiselect-Change.beforedelete()|
  Change.afterinsert()		|multiselect-Change.afterinsert()|
  Change.apply()		|multiselect-Change.apply()|
  Change.mapapply()		|multiselect-Change.mapapply()|

* NeatTask class~
  NeatTask			|multiselect-class-NeatTask|
  NeatTask.call()		|multiselect-NeatTask.call()|
  NeatTask.execute()		|multiselect-NeatTask.execute()|
  NeatTask.append()		|multiselect-NeatTask.append()|
  NeatTask.trigger()		|multiselect-NeatTask.trigger()|
  NeatTask.clear()		|multiselect-NeatTask.clear()|
  NeatTask.isactive()		|multiselect-NeatTask.isactive()|
  NeatTask.skip()		|multiselect-NeatTask.skip()|
  NeatTask.repeat()		|multiselect-NeatTask.repeat()|
  NeatTask.leftcount()		|multiselect-NeatTask.leftcount()|
  NeatTask.hasdone()		|multiselect-NeatTask.hasdone()|

* Task class~
  Task				|multiselect-class-Task|
  Task.waitfor()		|multiselect-Task.waitfor()|
  Task.cancel()			|multiselect-Task.cancel()|
  Task.call()			|multiselect-Task.call()|
  Task.execute()		|multiselect-Task.execute()|
  Task.append()			|multiselect-Task.append()|
  Task.trigger()		|multiselect-Task.trigger()|
  Task.clear()			|multiselect-Task.clear()|
  Task.isactive()		|multiselect-Task.isactive()|
  Task.skip()			|multiselect-Task.skip()|
  Task.repeat()			|multiselect-Task.repeat()|
  Task.leftcount()		|multiselect-Task.leftcount()|
  Task.hasdone()		|multiselect-Task.hasdone()|

* TaskChain class~
  TaskChain			|multiselect-class-TaskChain|
  TaskChain.event()		|multiselect-TaskChain.event()|
  TaskChain.timer()		|multiselect-TaskChain.timer()|
  TaskChain.hook()		|multiselect-TaskChain.hook()|
  TaskChain.trigger()		|multiselect-TaskChain.trigger()|
  TaskChain.waitfor()		|multiselect-TaskChain.waitfor()|
  TaskChain.cancel()		|multiselect-TaskChain.cancel()|
  TaskChain.repeat()		|multiselect-TaskChain.repeat()|
  TaskChain.leftcount()		|multiselect-TaskChain.leftcount()|
  TaskChain.hasdone()		|multiselect-TaskChain.hasdone()|

------------------------------------------------------------------------------
Multiselect module~
					*multiselect-module-Multiselect*

This module holds a function to get the "global" multiselector instance,
|multiselect-Multiselect.load()|.

Additionally, class constructors and utility functions are included. These
might be unnecessary but might be helpful to develop a plugin.



multiselect#import()			*multiselect#import()*
	This function returns a `Multiselect` module. >
		let s:Multiselect = multiselect#import()
<

				*multiselect-Multiselect.DEFAULTHIGROUP*
Multiselect.DEFAULTHIGROUP    [string]
	This is the default name of highlight group for the selected region,
	"MultiselectItem".


					*multiselect-Multiselect.load()*
Multiselect.load()    [function]
	This function returns the `Multiselector` instance.
	See |multiselect-class-Multiselector|. >
		let s:multiselector = s:Multiselect.load()
<
	Users can communicate with the instance with the provided keymappings
	|multiselect-keymappings|.


  - class constructors
					*multiselect-Multiselect.Region()*
Multiselect.Region({head}[, {tail}[, {type}[, {extended}]]])    [function]
Multiselect.Region({lnum})
Multiselect.Region({startlnum}, {endlnum})
Multiselect.Region({region})
	This is the constructor of `Region` class, it is a class to represent
	a region of a buffer. See |multiselect-class-Region|.

	{head} and {tail} are the edge positions of the region. These
	positions are a list like a return value of |getpos()|.

	{type} is a kind of the region:
	  "char" or "v": character-wise region
	  "line" or "V": line-wise region
	  "block" or "\<C-v>": block-wise region
	A new region would be character-wise if {type} is omitted.

	{extended} is effective only when the region is block-wise. It is a
	boolean (0 or 1), if {extended} is |TRUE| (1) the end column of each
	line is extended to the end of line. See |v_$|.
	|FALSE| (0) if omitted.  >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let region = s:Multiselect.Region(head, tail, 'block', 1)
<
	With only {head}, it returns an character-wise `Region` instance of a
	character, its head and tail is same.

	With only {lnum}, it returns an line-wise `Region` instance
	representing the line {lnum}.

	With {startlnum} and {endlnum}, it returns an line-wise `Region`
	instance representing the range from {startlnum} to {endlnum}.

	With {region}, {region} is an instance of `Region` class or its
	subclasses, it returns an `Region` instance points the same region
	with {region}. The returned value is not same instance with {region},
	that is, `{region} isnot# Multiselect.Region({retion})` is true.


					*multiselect-Multiselect.Item()*
Multiselect.Item({head}[, {tail}[, {type}[, {extended}]]])   [function]
Multiselect.Item({lnum})
Multiselect.Item({startlnum}, {endlnum})
	This is the constructor of `Item` class, it is a subclass of `Region`
	class used for handling a selection region on a buffer.
	See |multiselect-class-Item|.

	The arguments are common with `Multiselect.Region()`.  >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let item = s:Multiselect.Item(head, tail, 'block', 1)
<

					*multiselect-Multiselect.Change()*
Multiselect.Change()    [function]
	This is the constructor of `Change` class. It is employed to track a
	position after some edits. See |multiselect-class-Change|.


					*multiselect-Multiselect.NeatTask()*
Multiselect.NeatTask()    [function]
	This is the constructor of `NeatTask` class.
	See |multiselect-class-NeatTask|.
	
	This class is used to assemble several processes and trigger them all
	at onece, and is also a base class of the following classes.
	|multiselect-class-EventTask|
	|multiselect-class-TimerTask|
	|multiselect-class-Task|


					*multiselect-Multiselect.EventTask()*
Multiselect.EventTask()    [function]
	This is the constructor of `EventTask` class. It is employed to hook
	processes for |autocmd-events|. See |multiselect-class-EventTask|.


					*multiselect-Multiselect.TimerTask()*
Multiselect.TimerTask()    [function]
	This is the constructor of `TimerTask` class. It is employed to delay
	the execution of processes. See |multiselect-class-TimerTask|.


					*multiselect-Multiselect.Task()*
Multiselect.Task()    [function]
	This is the constructor of `Task` class. It is employed to
	obtain a task executed by multiple triggers.
	See |multiselect-class-Task|.


					*multiselect-Multiselect.TaskChain()*
Multiselect.TaskChain()    [function]
	This is the constructor of `TaskChain` class. It makes a successive
	sequence of autocmd events and timers.
	See |multiselect-class-TaskChain|.


  - utility functions
					*multiselect-Multiselect.shiftenv()*
Multiselect.shiftenv({expr}, {Filterexpr})    [function]
	This function sets 'indentkeys' or 'cinkeys' as its default and
	returns a |Dictionary| including the original setting. It will be
	passed to |multiselect-Multiselect.restoreenv()| to restore it.
	See |multiselect-howtomakeaplugin|.
>
		let s:shiftenv = s:Multiselect.shiftenv
		let s:restoreenv = s:Multiselect.restoreenv
		let indentopt = s:shiftenv()
		" do something
		call s:restoreenv(indentopt)
<

					*multiselect-Multiselect.restoreenv()*
Multiselect.restoreenv({expr}, {Filterexpr})    [function]
	This function accepts the return value of
	|multiselect-Multiselect.shiftenv()|, and restore the original
	indent-option settings.
	See |multiselect-howtomakeaplugin|.
>
		let s:shiftenv = s:Multiselect.shiftenv
		let s:restoreenv = s:Multiselect.restoreenv
		let indentopt = s:shiftenv()
		" do something
		call s:restoreenv(indentopt)
<

					*multiselect-Multiselect.str2type()*
Multiselect.str2type({str})    [function]
	This function returns a string representing a type of region.
	This function returns "char" if {str} is "char" or "v".
	This function returns "line" if {str} is "line" or "V".
	This function returns "block" if {str} is "block" or "<C-v>"
	(a single CTRL-V character). See |visualmode()|. >
		let s:str2type = s:Multiselect.str2type

		let type = str2type('char')
		" type ==# 'char'

		let type = str2type('v')
		" type ==# 'char'

		let type = str2type('line')
		" type ==# 'line'

		let type = str2type('V')
		" type ==# 'line'

		let type = str2type('block')
		" type ==# 'block'

		let type = str2type("\<C-v>")
		" type ==# 'block'
<
	This function ignores a number after "<C-v>". See |getregtype()|. >
		let type = str2type("\<C-v>10")
		" type ==# 'block'
<

				*multiselect-Multiselect.str2visualcmd()*
Multiselect.str2visualcmd({str})    [function]
	This function returns a character to enter a certain visual mode.
	This function returns "char" if {str} is "char" or "v".
	This function returns "line" if {str} is "line" or "V".
	This function returns "block" if {str} is "block" or "<C-v>"
	(a single CTRL-V character). See |visualmode()|. >
		let s:str2visualcmd = s:Multiselect.str2visualcmd

		let type = str2visualcmd('char')
		" type ==# 'v'

		let type = str2visualcmd('v')
		" type ==# 'v'

		let type = str2visualcmd('line')
		" type ==# 'V'

		let type = str2visualcmd('V')
		" type ==# 'V'

		let type = str2visualcmd('block')
		" type ==# "\<C-v>"

		let type = str2visualcmd("\<C-v>")
		" type ==# "\<C-v>"
<
	This function ignores a number after "<C-v>". See |getregtype()|. >
		let type = str2visualcmd("\<C-v>10")
		" type ==# "\<C-v>"
<

					*multiselect-Multiselect.inorderof()*
Multiselect.inorderof({pos1}, {pos2})    [function]
	This function returns |TRUE| if {pos1} is located former than {pos2}.
>
		let s:inorderof = s:Multiselect.inorderof

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inorderof([0, 2, 3, 0], [0, 3, 1, 0])
		" bool is TRUE

		let bool = s:inorderof([0, 2, 3, 0], [0, 1, 1, 0])
		" bool is FALSE

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 2, 0])
		" bool is FALSE

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 3, 0])
		" bool is FALSE
<

					*multiselect-Multiselect.inbetween()*
Multiselect.inbetween({pos}, {head}, {tail})    [function]
	This function returns |TRUE| is {pos} is in between {head} and {tail}.
>
		let s:inbetween = s:Multiselect.inbetween
		let pos = [0, 2, 3, 0]

		let bool = s:inbetween(pos, [0, 2, 2, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 3, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 2, 0], [0, 2, 3, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 3, 0], [0, 2, 3, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 1, 1, 0], [0, 3, 1, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 1, 0], [0, 2, 2, 0])
		" bool is FALSE

		let bool = s:inbetween(pos, [0, 2, 4, 0], [0, 2, 5, 0])
		" bool is FALSE
<

					*multiselect-Multiselect.isextended()*
Multiselect.isextended()    [function]
	This function returns |TRUE| if the last visual selection is
	block-wise and |v_$| is used. >
		let s:isextended = s:Multiselect.isextended

		execute "normal! \<C-v>2j$"
		execute "normal! \<Esc>"
		let bool = s:isextended()
		" bool is TRUE

		execute "normal! \<C-v>2j"
		execute "normal! \<Esc>"
		let bool = s:isextended()
		" bool is FALSE
<


------------------------------------------------------------------------------
Multiselector class~
					*multiselect-class-Multiselector*

A developer can access to the multiselector instance by `Multiselect.load()`
function. |multiselect-Multiselect.load()|

  - members
					*multiselect-Multiselector.name*
Multiselector.name    [string]
	The identifier of the `Multiselector` instance. It does not affect any
	functionality.


					*multiselect-Multiselector.bufnr*
Multiselector.bufnr    [number]
	The current buffer number belonging to.


					*multiselect-Multiselector.higroup*
Multiselector.higroup    [string]
	The highlight group name applied for the selection regions.


					*multiselect-Multiselector.itemlist*
Multiselector.itemlist    [list]
	The list of the current multiple selection items. The items are the
	instances of `Item` class.
	NOTE: Do not change this list directly, use the below methods instead.


  - main interfaces
					*multiselect-Multiselector.check()*
Multiselector.check({head}[, {tail}[, {type}[, {extended}]]])    [method]
Multiselector.check({lnum})
Multiselector.check({startlnum}, {endlnum})
Multiselector.check({region})
	This method produces an `Item` instance and add it into
	`Multiselector.itemlist`. This method returns the added item.
	|multiselect-Multiselector.itemlist|
	|multiselect-class-Item|

	The arguments are common with `Multiselect.Region()`.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'block', 1)
		call s:multiselector.check(region)
<

				    *multiselect-Multiselector.checkpattern()*
Multiselector.checkpattern({pat}[, {region}])    [method]
	This method searches the texts matching with the assigned regular
	expression {pat} and add them as multiselections into
	`Multiselect.itemlist`. This method returns a list of the added item.
	|multiselect-Multiselector.itemlist|


					*multiselect-Multiselector.uncheck()*
Multiselector.uncheck({head}[, {tail}[, {type}[, {extended}]]])    [method]
Multiselector.uncheck({lnum})
Multiselector.uncheck({startlnum}, {endlnum})
Multiselector.uncheck({region})
	This method removes items in `Multiselector.itemlist`, it removes the
	items touching with the assigned region.
	|multiselect-Multiselector.itemlist|

	The arguments are common with `Multiselect.Region()`.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let region = s:Multiselect.Region(head, tail, 'line')
		call s:multiselector.uncheck(region)
<

				*multiselect-Multiselector.uncheckall()*
Multiselector.uncheckall()    [method]
	This method removes all the items from `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist| >
		call s:multiselector.uncheckall()
<

					*multiselect-Multiselector.emit()*
Multiselector.emit([{Filterexpr}])    [method]
	This method removes items from `Multiselector.itemlist` and returns a
	list of these items. |multiselect-Multiselector.itemlist|

	Without {Filterexpr}, it removes all the items. >
		let itemlist = s:multiselector.emit()
<
	With {Filterexpr}, this method evaluates {Filterexpr}, a |Funcref|,
	for each item in `Multiselector.itemlist` with two arguments,
	an item index and an item, and removes the items that {Filterexpr}
	returns |TRUE|.
	  - Example1: emit items inside the visual selection region >
		let head = getpos("'<")
		let tail = getpos("'>")
		let type = visualmode()
		let region = s:Multiselect.Region(head, tail, type)
		let itemlist = s:multiselector.emit(
			\ {_, item -> item.isinside(region)})
<
	  NOTE: You can use an alias `Multiselector.emit_inside()` instead.
	        |multiselect-Multiselector.emit_inside()|

	  - Example2: emit items touching the cursor >
		let curpos = getpos('.')
		let itemlist = s:multiselector.emit(
			\ {_, item -> item.touches(curpos)})
<
	  NOTE: You can use an alias `Multiselector.emit_touching()` instead.
	        |multiselect-Multiselector.emit_touching()|


				*multiselect-Multiselector.emit_inside()*
Multiselector.emit_inside({head}[, {tail}[, {type}[, {extended}]]])   [method]
Multiselector.emit_inside({lnum})
Multiselector.emit_inside({startlnum}, {endlnum})
Multiselector.emit_inside({region})
	This method removes items from `Multiselector.itemlist` and returns a
	list of these items. This method removes only the items inside the
	assigned region will be removed to return.
	|multiselect-Multiselector.itemlist|

	The arguments are common with `Multiselect.Region()`.
	|multiselect-Multiselect.Region()| >
		let head = getpos("'<")
		let tail = getpos("'>")
		let type = visualmode()
		let region = s:Multiselect.Region(head, tail, type)
		let itemlist = s:multiselector.emit_inside(region)
<
	This actually equals to the above Example1 in `Multiselector.emit()`.
	|multiselect-Multiselector.emit()|


				*multiselect-Multiselector.emit_touching()*
Multiselector.emit_touching({head}[, {tail}[, {type}[, {extended}]]]) [method]
Multiselector.emit_touching({lnum})
Multiselector.emit_touching({startlnum}, {endlnum})
Multiselector.emit_touching({region})
	This method removes items from `Multiselector.itemlist` and returns a
	list of these items. This method removes only the items touching the
	assigned region will be removed to return.
	|multiselect-Multiselector.itemlist|

	The arguments are common with `Multiselect.Region()`.
	|multiselect-Multiselect.Region()| >
		let curpos = getpos('.')
		let itemlist = s:multiselector.emit_touching(curpos)
<
	This actually equals to the above Example2 in `Multiselector.emit()`.
	|multiselect-Multiselector.emit()|


					*multiselect-Multiselector.filter()*
Multiselector.filter({Filterexpr})    [method]
	This method filters the items in  `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|

	{Filterexpr} is an |Funcref|. {Filterexpr} is evaluated with two
	arguments, an index and an item, for each item in
	`Multiselector.itemlist`, and when the result is |FALSE|, this
	function removes the item.

	The resulted `Multiselector.itemlist` is returned.

	  - Example1: filter items except in line 5 >
		let pos = [0, 5, 1, 0]
		let line5 = s:Multiselect.Region(pos, pos, 'V')
		call s:multiselector.filter(
			\ {_, item -> item.isinside(line5)})
<
	|multiselect-Multiselect.Region()|
	|multiselect-class-Region| |multiselect-class-Item|
	|multiselect-Region.isinside()|

	  - Example2: filter items outside the visual selection >
		let vhead = getpos("'<")
		let vtail = getpos("'>")
		let vmode = visualmode()
		let visual = s:Multiselect.Region(vhead, vtail, vmode)
		call s:multiselector.filter(
			\ {_, item -> item.isinside(visual)})
<
	|multiselect-Multiselect.Region()|
	|multiselect-class-Region| |multiselect-class-Item|
	|multiselect-Region.isinside()|


					*multiselect-Multiselector.sort()*
Multiselector.sort({itemlist})    [function]
	This method sorts the items in {itemlist}. An item in {itemlist}
	should be an instance of `Item` class. An item closer to the beginning
	of a buffer comes to the earlier order in the {itemlist}; however if
	blockwise items and characterwise items are in a same line, these
	items are sorted by screen columns. The items at left-side comes
	earlier. >
		"#" represents selection and the number is the order in the
		sorted list

		##1##	#####	##4##
			##3##
		##2##	#####	##5##
<
	The sort operation is done in-place, thus this is destructive to
	{itemlist}. If you want a {itemlist} to remain unmodified make a copy
	first: >
		let copied = copy(itemlist)
		call s:multiselector.sort(copied)
<
	The return value of `Multiselector.enumerate()` is also acceptable as
	a {itemlist}. >
		let itemlist = s:multiselector.enumerate()
		call s:multiselector.sort(itemlist)
<

  - keymap interfaces
				*multiselect-Multiselector.keymap_check()*
Multiselector.keymap_check({mode})    [method]
	This method has the same function with the keymapping
	|<Plug>(multiselect-check)|.

	This method registers a current visual selection area as a multiple
	selection area. In normal mode, it registers a |word| under the
	cursor.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode.


			     *multiselect-Multiselector.keymap_checkpattern()*
Multiselector.keymap_checkpattern({mode}, {pat})    [method]
	This method is the base function of the keymapping
	|<Plug>(multiselect-checksearched)|.

	This method registers the texts matching with the given regular
	expression pattern {pat}. In normal mode, it registers all the matched
	texts in the current buffer. In visual mode, it registers the matched
	pattern in the visual-selected range.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode.


				*multiselect-Multiselector.keymap_uncheck()*
Multiselector.keymap_uncheck({mode})    [method]
	This method has the same function with the keymapping
	|<Plug>(multiselect-uncheck)|.

	This method deletes registered multiselect items. In normal mode,
	it deletes an item under the cursor. In visual mode, it deletes
	registered items in the current visual-selected range.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode.


			       *multiselect-Multiselector.keymap_uncheckall()*
Multiselector.keymap_uncheckall()    [method]
	This method has the same function with the keymapping
	|<Plug>(multiselect-uncheckall)|.

	This method deletes all registered items.


				*multiselect-Multiselector.keymap_undo()*
Multiselector.keymap_undo()    [method]
	This method has the same function with the keymapping
	|<Plug>(multiselect-undo)|.

	This method undo the last check or uncheck action. This undo itself is
	an action, thus the undo action will be undone by the subsequent call
	of .keymap_undo(). That is, the undo depth is currently only one
	times.


			      *multiselect-Multiselector.keymap_next()*
Multiselector.keymap_next({mode})    [method]
	This method has the same function with the keymapping
	|<Plug>(multiselect-next)|.

	This method moves the cursor to the next multiselect item.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode.


			      *multiselect-Multiselector.keymap_previous()*
Multiselector.keymap_previous({mode})    [method]
	This method has the same function with the keymapping
	|<Plug>(multiselect-previous)|.

	This method moves the cursor to the previous multiselect item.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode.


			      *multiselect-Multiselector.keymap_multiselect()*
Multiselector.keymap_multiselect({mode})    [method]
	This method has the same function with the keymapping
	|<Plug>(multiselect)|.

	|Normal| mode: This keymapping selects texts matching with the |word|
	under the cursor. If the cursor is on a multiselection, only the texts
	inside the region will be selected.

	|characterwise-visual| mode:
	If the visual selection includes one or more multiselection, this
	keymapping removes the items outside the visual selection.

	If the visual selection is included in a multiselection, this
	keymapping multi-selects texts matching with the selected string
	inside the original multiselection.

	Otherwise this keymapping multi-selects texts matching with the
	selected string over the current buffer.

	|linewise-visual| or |blockwise-visual| mode:
	If the visual selection includes one or more multiselection, this
	keymapping removes the items outside the visual selection.

	Otherwise, this keymapping selects the selection region.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode.


				*multiselect-Multiselector.keymap_broadcast()*
Multiselector.keymap_broadcast({cmd})   [method]
	This method is the base function of broadcasting textobjects.

	{cmd} is a {motion} command or a kind of |text-objects|. This method
	works as a {cmd} if it is used in |characterwise| or
	|blockwise-visual| mode. In case it is used in |linewise-visual| mode,
	this method tries the {cmd} in each lines at the cursor column to
	select texts. For example, given that the buffer is now: >
		fooo
		  bar
		 bazzzz
<
	Visual-select |linewise| the three lines and put the cursor at the 3rd
	or 4th column, and then use this method with |iw| as {cmd} to
	multiselect "fooo", "bar" and "bazzzz".


  - low-level interfaces
					*multiselect-Multiselector.append()*
Multiselector.append({item})    [method]
	This method append items in {item} into `Multiselector.itemlist`.
	The {item} should be an instance of `Item` class or a list of the
	instances.
	The items are appended at the end of `Multiselector.itemlist`.
	This method returns `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|
>
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]

		call s:multiselector.append(itemlist)
		" s:multiselector.itemlist == [item1, item2, item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|


					*multiselect-Multiselector.remove()*
Multiselector.remove({idx}[, {end}])    [method]
Multiselector.remove({indexlist})
	This method removes the item in  `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|

	Without {end}: Remove the item at {idx} from `Multiselector.itemlist`
	and return the item. >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let lastitem = s:multiselector.remove(-1)
		" lastitem is item3
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.append()|

	With {end}: Remove items from {idx} to {end} and return a |List| of
	these items. >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let removeditems = s:multiselector.remove(0, 1)
		" removeditems == [item1, item2]
<
	This method can removes the item also by a list of indexes. >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let removed = s:multiselector.remove([0, 2])
		" removed is [item1, item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.append()|


				*multiselect-Multiselector.enumerate()*
Multiselector.enumerate([{Filterexpr}])    [method]
	This method returns a list of lists of an index and an item.
	Note that this method does not change uncheck the returned items,
	not like `Multiselector.emit()`.
	|multiselect-Multiselector.emit()| >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let list = s:multiselector.enumerate()
		" list == [[0, item1], [1, item2], [2, item3]]
<
	With {Filterexpr}, it returns the items that {Filterexpr} return
	|TRUE|. {Filterexpr} is a |Funcref| and it is evaluated for each
	item in `Multiselector.itemlist` with two arguments, an item index and
	an item itself. >
		let list = s:multiselector.enumerate(
		         \ {index, item -> item.head[2] != 2})
		" list == [[0, item1], [2, item3]]
<

					*multiselect-Multiselector.itemnum()*
Multiselector.itemnum([{Filterexpr}])    [method]
	This method returns the number of items in  `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist| >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let nr = s:multiselector.itemnum()
		" nr == 3
<
	{Filterexpr} is a |Funcref|. If {Filterexpr} is assigned, this method
	evaluates {Filterexpr} for each items and count the number of items
	which {Filterexpr} returns |TRUE|. The {Filterexpr} is evaluated with
	two arguments, index of the item and the item itself. The item is an
	instance of `Item` class. >
		" count the number of items in line 1
		call s:multiselector.itemnum({i, item -> item.head[1] == 1})
<

					*multiselect-Multiselector.isempty()*
Multiselector.isempty()    [method]
	This method returns a boolean; |TRUE| if `Multiselector.itemlist` is
	empty, otherwise |FALSE|. |multiselect-Multiselector.itemlist| >
		call s:multiselector.uncheckall()
		let bool = s:multiselector.isempty()
		" bool is 1

		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let bool = s:multiselector.isempty()
		" bool is 0
<

				*multiselect-Multiselector.lastevent()*
Multiselector.lastevent()    [method]
	This method returns a history of the last event; check or uncheck. The
	return value is a dictionary which have the following keys.
	  event: "check" or "uncheck"
	  itemlist: a list of checked or unchecked items
>
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.append(itemlist)

		let last = s:multiselector.lastevent()
		" last.event ==# 'check'
		" last.itemlist == [item1, item2, item3]

		call s:multiselector.remove(-1)

		let last = s:multiselector.lastevent()
		" last.event ==# 'uncheck'
		" last.itemlist == [item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.append()|
	|multiselect-Multiselector.remove()|


					*multiselect-Multiselector.show()*
Multiselector.show()    [method]
	This method highlight all the items in `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|

	Unless you turned off the highlightings by `Multiselector.quench()`
	intentionally, you don't need to use this method.
	|multiselect-Multiselector.quench()|
>
		" hide multiple selection
		call s:multiselector.quench()

		" show up again
		call s:multiselector.show()
<

					*multiselect-Multiselector.quench()*
Multiselector.quench()    [method]
	This method turns off the highlightings of multiple selection items on
	the current buffer. It does not unselect, just hide. You can use
	`Multiselector.show()` to highlight them again.
	|multiselect-Multiselector.show()|
>
		" hide multiple selection
		call s:multiselector.quench()

		" show up again
		call s:multiselector.show()
<

				*multiselect-Multiselector.unsafe_append()*
Multiselector.unsafe_append({item})    [method]
	This method append items in {item} into `Multiselector.itemlist` like
	|multiselect-Multiselector.append()| but this method does not carry
	out the overlapping check for the items in {item}. Thus it works
	faster than |multiselect-Multiselector.append()| but possibly causes
	problems. Basically you should keep using
	|multiselect-Multiselector.append()| for safe, if you are really sure
	that no overlapping items in {item} and have performance problems,
	then use this method.


  - event controls
					*multiselect-Multiselector.event()*
Multiselector.event({event})    [method]
	This method returns an `EventTask` class instance specified by {event}
	for the control of the `Multiselector` instance itself.
	See |multiselect-class-EventTask|.

	This plugin prepares `EventTask` class instances for |BufLeave|,
	|TabLeave|, |CmdwinEnter|, |CmdwinLeave|, |TextChanged|,
	|InsertEnter| and |WinNew|.

	An initialization process is executed in |BufLeave|; all the items are
	unchecked and clear |multiselect-Multiselector.bufnr|.

	An initialization process is executed in |TabLeave|; all the items are
	unchecked and clear |multiselect-Multiselector.bufnr|.

	A pending process is executed in |CmdwinEnter|; some information of
	`Multiselector` instance is saved and switched to the one for the
	|command-line-window| temporary.

	An initialization process and a resume process are executed in
	|CmdwinLeave|; the saved information in the previous pending process
	is restored.

	All the multiselect items in the current buffer are unchecked in
	|TextChanged|.

	All the multiselect items in the current buffer are unchecked in
	|InsertEnter|.

	When a new window is opened and if it displays the same buffer,
	the current multiselect items are highlighted in |WinNew| event.



------------------------------------------------------------------------------
Region class~
					*multiselect-class-Region*

The constructor of `Region` class is available with `Multiselect` module.
|multiselect-Multiselect.Region()|

					*multiselect-Region.head*
Region.head    [list]
	This is the head position of the `Region` on a buffer. It is an
	four-item list and can be used for the argument of |setpos()|. >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call setpos('.', region.head)
		" getpos('.') == head
<

					*multiselect-Region.tail*
Region.tail    [list]
	This is the tail position of the `Region` on a buffer. It is an
	four-item list and can be used for the argument of |setpos()|. >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call setpos('.', region.tail)
		" getpos('.') == tail
<

					*multiselect-Region.type*
Region.type    [string]
	This is a string standing for the type of the `Region`; "char", "line"
	or "block".


					*multiselect-Region.extended*
Region.extended    [boolean]
	This is a boolean which is effective only when the `Region` is
	block-wise. It is |TRUE| if the end column of each line is extended to
	the end of line, otherwise |FALSE| (0). See |v_$|.


					*multiselect-Region.select()*
Region.select()    [method]
	This method selects the area of `Region`.
	  - Example: Delete a Region >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call region.select()
		normal! d
<
	  This is almost same as: >
		normal! v
		call setpos('.', [0, 1, 1, 0])
		normal! o
		call setpos('.', [0, 1, 3, 0])
		normal! d
<
	This method can handle also line-wise and block-wise region
	appropriately.


					*multiselect-Region.yank()*
Region.yank()    [method]
	This method yank the text of the `Region` and return the string. >
		call setline(1, 'foo bar baz')
		let head = [0, 1, 5, 0]
		let tail = [0, 1, 7, 0]
		let region = s:Multiselect.Region(head, tail, 'char')
		let text = region.yank()
		echo text   " bar
<

					*multiselect-Region.includes()*
Region.includes({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.includes({lnum})
Region.includes({startlnum}, {endlnum})
Region.includes({region})
	This method returns |TRUE| if the `Region` instance includes an
	assigned region, otherwise |FALSE|.

	The arguments are common with `Multiselect.Region()`.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.includes([0, 1, 1, 0])
		" bool is FALSE

		let bool = region1.includes([0, 1, 2, 0])
		" bool is TRUE

		let bool = region1.includes(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.includes(region2)
		" bool is FALSE

		let head = [0, 1, 2, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.includes(region3)
		" bool is TRUE
<

					*multiselect-Region.isinside()*
Region.isinside({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.isinside({lnum})
Region.isinside({startlnum}, {endlnum})
Region.isinside({region})
	This method returns |TRUE| if the `Region` instance is inside an
	assigned region, otherwise |FALSE|.

	The arguments are common with `Multiselect.Region()`.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.isinside(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region2)
		" bool is FALSE

		let head = [0, 1, 2, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region3)
		" bool is FALSE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 5, 0]
		let region4 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region4)
		" bool is TRUE
<

					*multiselect-Region.touches()*
Region.touches({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.touches({lnum})
Region.touches({startlnum}, {endlnum})
Region.touches({region})
	This method returns |TRUE| if the `Region` instance is touching an
	assigned region, otherwise |FALSE|.

	The arguments are common with `Multiselect.Region()`.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.touches([0, 1, 1, 0])
		" bool is FALSE

		let bool = region1.touches([0, 1, 2, 0])
		" bool is TRUE

		let bool = region1.touches([0, 1, 4, 0])
		" bool is TRUE

		let bool = region1.touches([0, 1, 5, 0])
		" bool is FALSE

		let bool = region1.touches(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 2, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region2)
		" bool is FALSE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region3)
		" bool is TRUE

		let head = [0, 1, 4, 0]
		let tail = [0, 1, 6, 0]
		let region4 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region4)
		" bool is TRUE

		let head = [0, 1, 5, 0]
		let tail = [0, 1, 6, 0]
		let region5 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region5)
		" bool is FALSE
<


------------------------------------------------------------------------------
Item class~
					*multiselect-class-Item*

The constructor of `Item` class is available with `Multiselect` module.
|multiselect-Multiselect.Item()|

`Item` class is a subclass of `Region` class, thus `Item` class inherites all
the properties of `Region` class.

					*multiselect-Item.id*
Item.id    [number]
	This is a number specific for each item.


					*multiselect-Item.bufnr*
Item.bufnr    [number]
	This is a buffer number of the item belonging to.


					*multiselect-Item.head*
Item.head    [list]
	See |multiselect-Region.head|.


					*multiselect-Item.tail*
Item.tail    [list]
	See |multiselect-Region.tail|.


					*multiselect-Item.type*
Item.type    [string]
	See |multiselect-Region.type|.


					*multiselect-Item.extended*
Item.extended    [boolean]
	See |multiselect-Region.extended|.


					*multiselect-Item.select()*
Item.select()    [method]
	See |multiselect-Region.select()|.


					*multiselect-Item.yank()*
Item.yank()    [method]
	See |multiselect-Region.yank()|.


					*multiselect-Item.includes()*
Item.includes()    [method]
	See |multiselect-Region.includes()|.


					*multiselect-Item.isinside()*
Item.isinside()    [method]
	See |multiselect-Region.isinside()|.


					*multiselect-Item.touches()*
Item.touches()    [method]
	See |multiselect-Region.touches()|.


					*multiselect-Item.show()*
Item.show({higroup})    [method]
	This is a method to highlight the item region on a buffer. It will be
	highlighted by {higroup}. |highlight-groups|


					*multiselect-Item.quench()*
Item.quench()    [method]
	This is a method to turn off the highlight of the item.


					*multiselect-Item.isshownin()*
Item.isshownin([{winid}])    [method]
	This method returns |TRUE| if the item is highlighted in the window
	pointed by {winid}. {winid} is a return value of |win_getid()|. If it
	is omitted, it returns the status of the current window.



------------------------------------------------------------------------------
Change class~
					*multiselect-class-Change*

This is an utility class to track a position after deletions and additions of
texts into the current buffer. It might be useful when a plugin developer
makes a new plugin to do well with |multiselect.vim|

Note that the `Change` class instance cannot track the change by 'autoindent'
option and its relatives ('smartindent', 'cindent', 'indentexpr') perfectly.

					*multiselect-Change.beforedelete()*
Change.beforedelete({head}[, {tail}[, {type}[, {extended}]]])    [method]
Change.beforedelete({lnum})
Change.beforedelete({startlnum}, {endlnum})
Change.beforedelete({region})
	This method should be called before deleting a text on the current
	buffer to record the region. The deletion is regarded as an
	|inclusive| delete action. Thus the last character pointed by {tail}
	is included.

	This method returns the `Change` instance itself.


					*multiselect-Change.afterinsert()*
Change.afterinsert({head}[, {tail}[, {type}[, {extended}]]])    [method]
Change.afterinsert({lnum})
Change.afterinsert({startlnum}, {endlnum})
Change.afterinsert({region})
	This method should be called after adding a text into the current
	buffer to record the region. The {tail} should point the ending edge
	of the insertion.

	This method returns the `Change` instance itself.


					*multiselect-Change.apply()*
Change.apply({pos})    [method]
Change.apply({region})
	This method calculates the position after a series of editings.
	This method updates the position (or a `Region` instance) in-place and
	returns it.

	NOTE: Change.apply() may not be effective with a lot of items.
	      Use Change.mapapply() for the case.
	      |multiselect-Change.mapapply()|


					*multiselect-Change.mapapply()*
Change.mapapply({itemlist})    [method]
	This method returns the same result with: >
		call map({itemlist}, 'change.apply(v:val)')
<
	but faster if the number of items in {itemlist} is larger. {itemlist}
	should be a list of positions or `Region` class instances.


  - Usage
The current buffer is like this. >
	foo bar baz
<
For example, if you want to track the cursor position after an edit, you
need to save the cursor position. >
	let curpos = getpos('.')
<
The cursor is on the 'z' of "baz" and then you are going to delete "bar" and
insert "x" instead.
Before deleting, you need to call `Change.beforedelete()`. >
	let bar = s:Multiselect.Region([0, 1, 5, 0], [0, 1, 7, 0], 'char')
	let change = s:Multiselect.Change()
	call change.beforedelete(bar)
<
Edit the buffer. >
	call bar.select()
	normal! cx
<
Now the buffer is: >
	foo x baz
<
After inserting a text, you need to call `Change.afterinsert()`. >
	call change.afterinsert(getpos("'["), getpos("']"), 'char')
<
After those processes, use `Change.apply()` to update the cursor position. >
	call change.apply(curpos)
	" curpos == [0, 1, 9, 0]
<
Finally you can move the cursor to the new position taking into account the
last edit. >
	call setpos('.', curpos)
<


------------------------------------------------------------------------------
NeatTask class~
					*multiselect-class-NeatTask*

`NeatTask` class is used to assemble several processes and trigger them all at
once. The processes are registered via |multiselect-NeatTask.call()|,
|multiselect-NeatTask.execute()| and |multiselect-NeatTask.append()|. >
	function! s:sayfoo() abort
		echo 'foo'
	endfunction

	let task = s:Multiselect.NeatTask()
	call task.call(function('s:sayfoo'), [])
	call task.execute('echo "foo"')
<

Those tasks are executed to call |multiselect-NeatTask.trigger()|, it executes
them in the order of registration. >
	call task.trigger()
<

|multiselect-NeatTask.repeat()| sets the number of executions; after the
number of executions done, |multiselect-NeatTask.trigger()| does nothing.
The default number of execution is 1. >
	let neattask = s:Multiselect.NeatTask()
	call neattask.execute('echo "foo"').repeat(1)

	" echo 'foo'
	call neattask.trigger()

	" does nothing
	call neattask.trigger()
<

`NeatTask` has its internal switch and it can be temporary off by
|multiselect-NeatTask.skip()|. >
	let neattask = s:Multiselect.NeatTask()
	call neattask.execute('echo "foo"').skip(1)

	" does nothing
	call neattask.trigger()

	" echo 'foo'
	call neattask.trigger()
<

					*multiselect-NeatTask.call()*
NeatTask.call({Funcref}, {args}[, {dict}])    [method]
	This method registers a task to call a |Funcref| with a |List| of
	{args} as arguments and. {dict} is for functions with the "dict"
	attribute. It will be used to set the local variable "self".
	|Dictionary-function| This method returns the task itself.
>
		function! s:sayfoo() abort
		    echo 'foo'
		endfunction

		" make a new task
		let neattask = s:Multiselect.NeatTask()
		call neattask.call(function('s:sayfoo'), [])

		" trigger the task
		call task.trigger()
<

					*multiselect-NeatTask.execute()*
NeatTask.execute({cmd})    [method]
	This method registers a task to execute an Ex command. This method
	returns the task itself.  >
		" make a new task
		let neattask = s:Multiselect.NeatTask().execute('echo "foo"')

		" trigger the task
		call task.trigger()
<

					*multiselect-NeatTask.append()*
NeatTask.append({task})    [method]
	This method registers a task to trigger other tasks. {task} should be
	an instance of `NeatTask` class or its subclasses. This method returns
	the task itself. >
		" make new tasks
		let task = s:Multiselect.NeatTask().execute('echo "foo"')
		let neattask = s:Multiselect.NeatTask().append(task)

		" trigger the task
		call neattask.trigger()
<

					*multiselect-NeatTask.trigger()*
NeatTask.trigger([{forcibly}])    [method]
	This method executes all the registered tasks.
	This method returns the `NeatTask` instance itself.

	If {forcibly} is given and it is |TRUE|, this method triggers the
	registered task even if the task has already done.
	|multiselect-NeatTask.hasdone()|


					*multiselect-NeatTask.clear()*
NeatTask.clear()    [method]
	This method clears all registered tasks. This method returns the
	`NeatTask` instance itself.


					*multiselect-NeatTask.clone()*
NeatTask.clone()    [method]
	This method returns another `NeatTask` instance which have the same
	task with itself.


					*multiselect-NeatTask.isactive()*
NeatTask.isactive()    [method]
	This method returns |TRUE| if the `NeatTask` is active, |FALSE|
	if it is not active.


					*multiselect-NeatTask.skip()*
NeatTask.skip([{count}])    [method]
	If this method is called, the following `NeatTask` is skipped
	(not executed) {count} times. {count} is 1 if omitted. If {count} is
	0, the skip count would be reset and the task will not skip after
	that. This method returns the `NeatTask` itself. >
		let neattask = s:Multiselect.NeatTask()
		call neattask.execute('echo "foo"').skip(1)

		" does nothing
		call neattask.trigger()

		" echo 'foo'
		call neattask.trigger()
<

					*multiselect-NeatTask.skipif()*
NeatTask.skipif({Funcref}, {args}[, {dict}])    [method]
	This method sets a condition to skip an action. If {Funcref} is
	evaluated with a |List| of {args} as arguments to return |TRUE|, the
	task will be finished immediately. {dict} is for functions with the
	"dict" attribute. It will be used to set the local variable "self".
	|Dictionary-function| This method returns the task object itself. >
		let neattask = s:Multiselect.NeatTask()
		call neattask.execute('echo foo').repeat(-1)
		call neattask.skipif({-> g:skip == 1}, [])

		" echo 'foo'
		let g:skip = 0
		call neattask.trigger()

		" does nothing
		let g:skip = 1
		call neattask.trigger()

		" echo 'foo'
		let g:skip = 2
		call neattask.trigger()
<
	A task accepts only one condition to skip.


					*multiselect-NeatTask.repeat()*
NeatTask.repeat([{count}])    [method]
	This method sets the number of execution. If {count} is negative, the
	`NeatTask` will be persistent. An `NeatTask` instance is produced as
	it is 1 in default. If {count} is omitted, it will reset the number
	of execution to the one last set. >
		" 'foo' will be displayed three times
		let neattask = s:Multiselect.NeatTask()
					   \.execute('echo "foo"')
					   \.repeat(3)

		call neattask.trigger()
		call neattask.trigger()
		call neattask.trigger()
		call neattask.trigger() " does nothing
<
	This method returns the task itself.


					*multiselect-NeatTask.leftcount()*
NeatTask.leftcount()    [method]
	This method returns the left number of execution.
	See |multiselect-NeatTask.repeat()|.


					*multiselect-NeatTask.hasdone()*
NeatTask.hasdone()    [method]
	This method returns |TRUE| if the task has done {count} times
	specified by |multiselect-NeatTask.repeat()|, otherwise |FALSE|.


					*multiselect-NeatTask.finishif()*
NeatTask.finishif({Funcref}, {args}[, {dict}])    [method]
	This method set a condition to finish the task. If {Funcref} is
	evaluated with a |List| of {args} as arguments to return |TRUE|, the
	task will be finished immediately. {dict} is for functions with the
	"dict" attribute. It will be used to set the local variable "self".
	|Dictionary-function| This method returns the task object itself. >
		let neattask = s:Multiselect.NeatTask()
		call neattask.execute('echo foo').repeat(-1)
		call neattask.finishif({-> g:finish == 1}, [])

		" echo 'foo'
		let g:finish = 0
		call neattask.trigger()

		" does nothing
		let g:finish = 1
		call neattask.trigger()
<
	A task accepts only one condition to finish.



------------------------------------------------------------------------------
Task class~
					*multiselect-class-Task*

`Task` class is a subclass of `NeatTask` class with multiple automatic
triggers, autocmd events and a delay time.
See also |multiselect-class-NeatTask|.

`Task` class instance inherits the methods of `NeatTask` class, and has
|multiselect-Task.waitfor()| and |multiselect-Task.cancel()| additionally.

`Task` finishes after an execution in default, this number of execution can be
changed by |multiselect-Task.repeat()|.


					*multiselect-Task.waitfor()*
Task.waitfor({triggers})    [method]
	This method starts to wait for an auto-trigger in {triggerlist}.
	{triggerlist} is a list of trigger names. The trigger name should be
	one of the following types.

	  * |String|: Regarded as an {event} |autocmd-events|, "*" is applied
	              for {pat} |autocmd-patterns|
	  * |List|  : Regarded as an |autocmd-events| and a |autocmd-patterns|
	              like [{event}, {pat}]
	  * |Number|: Regarded as a waiting {time} for a timer |timer|
>
		let task = s:Multiselect.Task().execute('echo "foo"')
		call task.waitfor(['TextChanged', ['InsertEnter', '*'], 100])
<
	This method returns the task itself.

					*multiselect-Task.cancel()*
Task.cancel()    [method]
	This method stops to execute the registered tasks.


					*multiselect-Task.call()*
Task.call({Funcref}, {args}[, {dict}])    [method]
	See |multiselect-NeatTask.call()|.


					*multiselect-Task.execute()*
Task.execute({cmd})    [method]
	See |multiselect-NeatTask.execute()|.


					*multiselect-Task.append()*
Task.append({task})    [method]
	See |multiselect-NeatTask.append()|.


					*multiselect-Task.trigger()*
Task.trigger([{forcibly}])    [method]
	See |multiselect-NeatTask.trigger()|.


					*multiselect-Task.clear()*
Task.clear()    [method]
	See |multiselect-NeatTask.clear()|.


					*multiselect-Task.isactive()*
Task.isactive()    [method]
	See |multiselect-NeatTask.isactive()|.


					*multiselect-Task.skip()*
Task.skip([{count}])    [method]
	See |multiselect-NeatTask.skip()|.


					*multiselect-Task.skipif()*
Task.skipif({Funcref}, {args}[, {dict}])    [method]
	See |multiselect-NeatTask.skipif()|.


					*multiselect-Task.repeat()*
Task.repeat([{count}])    [method]
	See |multiselect-NeatTask.repeat()|.


					*multiselect-Task.leftcount()*
Task.leftcount()    [method]
	See |multiselect-NeatTask.leftcount()|.


					*multiselect-Task.hasdone()*
Task.hasdone()    [method]
	See |multiselect-NeatTask.hasdone()|.


					*multiselect-Task.finishif()*
Task.finishif({Funcref}, {args}[, {dict}])    [method]
	See |multiselect-NeatTask.finishif()|.



------------------------------------------------------------------------------
TaskChain class~
					*multiselect-class-TaskChain*

`TaskChain` class makes a task triggered by a successive sequence of autocmd
events and timers.

Use |multiselect-TaskChain.hook()| to make a sequence, and set tasks to the
returned `NeatTask` instance. >
	let taskchain = s:Multiselect.TaskChain()
	let task1 = taskchain.event('InsertLeave')
	let task2 = taskchain.event('CursorMoved')
	call task2.execute('echo "foo"')
	call taskchain.waitfor()
<
The above example shows a message "foo" after leaving insert mode and then moving
cursor. You can write shorter: >
	let taskchain = s:Multiselect.TaskChain()
	call taskchain.event('InsertLeave')
	call taskchain.event('CursorMoved').execute('echo "foo"')
	call taskchain.waitfor()
<

					*multiselect-TaskChain.hook()*
TaskChain.hook({triggerlist})    [method]
	This method registers a multiple-triggered task. {triggers} is a list
	of trigger names. The trigger name could be one of the following
	types.

	  * |String|: Regarded as an {event} |autocmd-events|, "*" is applied
	              for {pat} |autocmd-patterns|
	  * |List|  : Regarded as an |autocmd-events| and a |autocmd-patterns|
	              like [{event}, {pat}]
	  * |Number|: Regarded as a waiting {time} for a timer |timer|

	This method returns a `NeatTask` object to be called by either one of
	those triggers. >
		let taskchain = s:Multiselect.TaskChain()
		let task1 = taskchain.event('CmdwinLeave')
		let task2 = taskchain.hook(['CursorMoved', 1000])
		call task2.execute('echo "original buffer"')
		call taskchain.waitfor()
<
	After leaving |cmdline-window|, you will see the message "original
	buffer" if you move cursor or wait for 1 second.
	|multiselect-class-NeatTask|
	|multiselect-NeatTask.repeat()|
	|multiselect-Task.waitfor()|


					*multiselect-TaskChain.trigger()*
TaskChain.trigger()    [method]
	This method executes the next task. This method returns the taskchain
	itself.


					*multiselect-TaskChain.waitfor()*
TaskChain.waitfor()    [method]
	This method starts the taskchain, after calling this method it waits
	for the first trigger to move for the next task.


					*multiselect-TaskChain.cancel()*
TaskChain.cancel()    [method]
	This method cancels the taskchain.
	This method returns the taskchain object itself.


					*multiselect-TaskChain.repeat()*
TaskChain.repeat()    [method]
	This method sets the number of execution. The default value is 1.


					*multiselect-TaskChain.leftcount()*
TaskChain.leftcount()    [method]
	This method returns the left number of execution.
	See |multiselect-TaskChain.repeat()|.


					*multiselect-TaskChain.hasdone()*
TaskChain.hasdone()    [method]
	This method returns |TRUE| if the task has done {count} times
	specified by |multiselect-TaskChain.repeat()|, otherwise |FALSE|.


					*multiselect-TaskChain.finishif()*
TaskChain.finishif({Funcref}, {args}[, {dict}])    [method]
	See |multiselect-NeatTask.finishif()|.



==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet::fdl=0:fen:fdm=marker:noet:
