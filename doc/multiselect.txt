*multiselect.txt*	A library for multiple selection
						Last change:20-Jan-2018.

Author  : machakann <https://github.com/machakann>
License : MIT license
Copyright (c) 2017 Masaaki Nakamura {{{

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
}}}

Requirement:	Vim 8.0 or higher

==============================================================================
INDEX					*multiselect-index*

INTRODUCTION				|multiselect-introduction|
KEYMAPPINGS				|multiselect-keymappings|
HIGHLIGHT GROUPS			|multiselect-higroups|
AUTOCMD EVENTS				|multiselect-events|
HOW TO MAKE A PLUGIN			|multiselect-pluginmaking|
API					|multiselect-api|

==============================================================================
INTRODUCTION				*multiselect-introduction*

*multiselect.vim* is a library to handle multiple selection areas in Vim text
editor. The multiple selection areas follow the below basic rules listed:

	1. Two selections cannot overlap. The newer one removes the old one.
	2. These areas are quenched if the current buffer is changed.
	3. These areas are quenched if the cursor moved to another buffer.
	4. These areas are quenched if the cursor moved to another |tabpage|.

This plugin only serves functions to select/unselect multiple visual selection
areas. |multiselect-keymappings| The further features are supplied by other
plugins.

The other plugins can communicate with this plugin through the provided
Application Programming Interfaces (API). |multiselect-api|

==============================================================================
KEYMAPPINGS				*multiselect-keymappings*

The following keymappings are available with |:nmap| and |:xmap|.

<Plug>(multiselect-check)		*<Plug>(multiselect-check)*
	This keymapping registers a current visual selection area as a
	multiple selection area. In normal mode, it registers a |word| under
	the cursor.

<Plug>(multiselect-checksearched)	*<Plug>(multiselect-checksearched)*
	This keymapping registers the texts matching with the last searched
	patten |@/|. In normal mode, it registers all the matched texts in the
	current buffer. In visual mode, it registers the matched pattern in
	the visual-selected range.

	NOTE: The following keymapping registers all texts matching with the
	      word under the cursor.
>
	nmap <Space>v *N<Plug>(multiselect-checksearched)
<
<Plug>(multiselect-uncheck)		*<Plug>(multiselect-uncheck)*
	This keymapping deletes registered multipleselet items. In normal
	mode, it deletes an item under the cursor. In visual mode, it deletes
	registered items in the current visual-selected range.

<Plug>(multiselect-uncheckall)		*<Plug>(multiselect-uncheckall)*
	This keymapping deletes all registered items.

<Plug>(multiselect-undo)		*<Plug>(multiselect-undo)*
	This keymapping rollback the last action.

<Plug>(multiselect)			*<Plug>(multiselect)*
	|Normal| mode: This keymapping removes an item under the cursor if
	the text is selected. Otherwise this keymapping selects the |word|
	under the cursor over the current buffer.

	|Visual| mode: If multiselect items are in the selection region, this
	keymapping removes the items outside the selection. Otherwise, this
	keymapping selects the selection region. If in character-wise visual
	mode, this keymapping selects all texts matching with the selected
	string over the current buffer.

==============================================================================
HIGHLIGHT GROUPS			*multiselect-higroups*

The multiselect items on a buffer will be highlighted like |Visual| selection.
The color of the highlight can be customized through the highlight groups.

MultiselectItem			*hl-MultiselectItem*
	The highlight group for a region of multiselect item. It is linked to
	|hl-VisualNOS| in default. >
		highlight default link MultiselectItem VisualNOS
<
	If |hl-VisualNOS| does not exist, it is linked to |hl-Visual|. >
		highlight default link MultiselectItem Visual
<
	The highlight color can be optimized by |:highlight| command. >
		highlight MultiselectItem ctermfg=White ctermbg=Red
		                               \ guifg=White   guibg=Red
<

==============================================================================
AUTOCMD EVENTS				*multiselect-events*

MultiselectInit				*MultiselectInit*
	This autocmd event is triggered when a `Multiselector` instance is
	initialized.

	In an initialization process, all the multiselect items are removed to
	empty `Multiselector.itemlist` and `Multiselector.bufnr` is cleared. >
		autocmd User MultiselectInit echom 'Initialized!'
<
	This is triggered when:
	  - A `Multiselector` instance is produced
	  - |BufLeave| event is triggered
	  - |TabLeave| event is triggered
	  - |CmdwinLeave| event is triggered

	|multiselect-class-Multiselector|
	|multiselect-Multiselector.itemlist|
	|multiselect-Multiselector.bufnr|


MultiselectCheckPost			*MultiselectCheckPost*
	This autocmd event is triggered when any multiselect item is added.
>
		autocmd User MultiselectCheckPost echom 'Check!'
<
	`Multiselector.lastevent()` method returns the selected items.
	|multiselect-Multiselector.lastevent()|

MultiselectUncheckPost			*MultiselectUncheckPost*
	This autocmd event is triggered when any multiselect item is removed.
>
		autocmd User MultiselectUncheckPost echom 'Uncheck!'
<
	`Multiselect.lastevent()` method returns the unselected items.
	|multiselect-Multiselector.lastevent()|

==============================================================================
HOW TO MAKE A PLUGIN			*multiselect-pluginmaking*

Anyone can make a new plugin utilizing this plugin. Here, let's make a plugin
which edit multiple selected texts converting to "foo", to learn how to use
the available API. This is, of course, not a useful plugin, but taking a
glance of the following processes may be helpful to start communicating with
the APIs. See the next |multiselect-api| section also.

Step 0~
Read |write-plugin| and prepare a plugin file: >
	~/.vim/plugin/fooize.vim
<
Although we will write everything this tiny plugin into it, if you make your
new plugin, it would be better to think the use of |autoload| scripts.

Step 1~
The first thing to do is to load the `Multiselect` module and to obtain an
`Multiselector` instance.
>
	" Multiselect module
	let s:Multiselect = multiselect#import()
<
This module contains some functions, constructors and constants, but in many
cases what you need is only the `s:Multiselect.load()` function. This function
returns a "global" `Multiselector` instance. Here, "global" means that it is
shared among all the other plugins.
>
	" Multiselector instance
	let s:multiselector = s:Multiselect.load()
<
Use this instance to get information and to control the multiple selections.



Step2~
Next, user may already have some selections, then get the positions of the
selections. Use `Multiselector.emit()` method to get all the items. The
"emitted" items are no longer selected.
>
	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif
	endfunction
<
Process each item one-by-one. An item of selection have a useful method to
re-select its range `Item.select()`. Use this method to re-select and edit it.

It is worth noting that items should be edited from the end of a buffer to the
beginning of a buffer. Because if an item was edited, it might changes the
position of the following items. It may cause a complete mess on the buffer.
Simply use `Multiselector.sort()` method to avoid the positional confusions.
>
	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  for item in reverse(itemlist)
	    call item.select()
	    normal! cfoo
	  endfor
	endfunction
<
The auto-indent may also cause the positional confusions. If in case your
plugin inserts texts into a buffer, it would be safer to turn off 'autoindent'
families temporary.
>
	function! s:stopautoindent() abort
	  let indentopt = {}
	  let indentopt.autoindent = &l:autoindent
	  let indentopt.smartindent = &l:smartindent
	  let indentopt.cindent = &l:cindent
	  let indentopt.indentexpr = &l:indentexpr
	  let &l:autoindent = 0
	  let &l:smartindent = 0
	  let &l:cindent = 0
	  let &l:indentexpr = ''
	  return indentopt
	endfunction

	function! s:restoreautoindent(indentopt) abort
	  let &l:autoindent = a:indentopt.autoindent
	  let &l:smartindent = a:indentopt.smartindent
	  let &l:cindent = a:indentopt.cindent
	  let &l:indentexpr = a:indentopt.indentexpr
	endfunction

	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  let indentopt = s:stopautoindent()
	  try
	    for item in reverse(itemlist)
	      call item.select()
	      normal! cfoo
	    endfor
	  finally
	    call s:restoreautoindent(indentopt)
	  endtry
	endfunction
<


Step 3~
The final step is to implement the interface to users. Here, we will implement
a command and a |Normal| mode keymapping.
>
	command! Fooize call Fooize()
	nnoremap <silent> <Space>f :<C-u>call Fooize()
<

The resulted plugin is:
>
	if exists("g:loaded_fooize")
	  finish
	endif
	let g:loaded_fooize = 1

	let s:Multiselect = multiselect#import()
	let s:multiselector = s:Multiselect.load()

	function! s:stopautoindent() abort
	  let indentopt = {}
	  let indentopt.autoindent = &l:autoindent
	  let indentopt.smartindent = &l:smartindent
	  let indentopt.cindent = &l:cindent
	  let indentopt.indentexpr = &l:indentexpr
	  let &l:autoindent = 0
	  let &l:smartindent = 0
	  let &l:cindent = 0
	  let &l:indentexpr = ''
	  return indentopt
	endfunction

	function! s:restoreautoindent(indentopt) abort
	  let &l:autoindent = a:indentopt.autoindent
	  let &l:smartindent = a:indentopt.smartindent
	  let &l:cindent = a:indentopt.cindent
	  let &l:indentexpr = a:indentopt.indentexpr
	endfunction

	function! Fooize() abort
	  let itemlist = s:multiselector.emit()
	  if empty(itemlist)
	    return
	  endif

	  call s:multiselector.sort(itemlist)
	  let indentopt = s:stopautoindent()
	  try
	    for item in reverse(itemlist)
	      call item.select()
	      normal! cfoo
	    endfor
	  finally
	    call s:restoreautoindent(indentopt)
	  endtry
	endfunction

	command! Fooize call Fooize()
	nnoremap <silent> <Space>f :<C-u>call Fooize()<CR>
<
This file is in `macros/multiselect/demo/fooize.vim`.

==============================================================================
API					*multiselect-api*

List of contents~

* Multiselect module~
  multiselect#import()		|multiselect#import()|
  Multiselect			|multiselect-module-Multiselect|

  Multiselect.DEFAULTHIGROUP
			       |multiselect-Multiselect.DEFAULTHIGROUP|
  Multiselect.load()		|multiselect-Multiselect.load()|
  Multiselect.Multiselector()	|multiselect-Multiselect.Multiselector()|
  Multiselect.Region()		|multiselect-Multiselect.Region()|
  Multiselect.Item()		|multiselect-Multiselect.Item()|

* Multiselector class~
  Multiselector			|multiselect-class-Multiselector|

  - members
  Multiselector.name
  Multiselector.bufnr
  Multiselector.higroup
  Multiselector.itemlist	|multiselect-Multiselector.itemlist|

  - main interfaces
  Multiselector.check()		|multiselect-Multiselector.check()|
  Multiselector.uncheck()	|multiselect-Multiselector.uncheck()|
  Multiselector.uncheckall()	|multiselect-Multiselector.uncheckall()|
  Multiselector.emit()		|multiselect-Multiselector.emit()|
  Multiselector.emit_inside()	|multiselect-Multiselector.emit_inside()|
  Multiselector.emit_touching()	|multiselect-Multiselector.emit_touching()|
  Multiselector.filter()	|multiselect-Multiselector.filter()|
  Multiselector.sort()		|multiselect-Multiselector.sort()|

  - keymap interfaces
  Multiselector.keymap_check()	|multiselect-Multiselector.keymap_check()|
  Multiselector.keymap_checkpattern()
			     |multiselect-Multiselector.keymap_checkpattern()|
  Multiselector.keymap_uncheck()
				|multiselect-Multiselector.keymap_uncheck()|
  Multiselector.keymap_uncheckall()
			       |multiselect-Multiselector.keymap_uncheckall()|

  - low-level interfaces
  Multiselector.extend()	|multiselect-Multiselector.extend()|
  Multiselector.add()		|multiselect-Multiselector.add()|
  Multiselector.remove()	|multiselect-Multiselector.remove()|
  Multiselector.enumerate()	|multiselect-Multiselector.enumerate()|
  Multiselector.itemnum()	|multiselect-Multiselector.itemnum()|
  Multiselector.isempty()	|multiselect-Multiselector.isempty()|
  Multiselector.lastevent()	|multiselect-Multiselector.lastevent()|
  Multiselector.show()		|multiselect-Multiselector.show()|
  Multiselector.quench()	|multiselect-Multiselector.quench()|

  -event controls
  Multiselector.event		|multiselect-Multiselector.event|

* Region class~
  Region			|multiselect-class-Region|
  Region.head			|multiselect-Region.head|
  Region.tail			|multiselect-Region.tail|
  Region.type			|multiselect-Region.type|
  Region.extended		|multiselect-Region.extended|
  Region.select()		|multiselect-Region.select()|
  Region.yank()			|multiselect-Region.yank()|
  Region.includes()		|multiselect-Region.includes()|
  Region.isinside()		|multiselect-Region.isinside()|
  Region.touches()		|multiselect-Region.touches()|

* Item class~
  Item				|multiselect-class-Item|
  Item.id			|multiselect-Item.id|
  Item.bufnr			|multiselect-Item.bufnr|
  Item.show()			|multiselect-Item.show()|
  Item.quench()			|multiselect-Item.quench()|

* Change class~
  Change			|multiselect-class-Change|
  Change.beforedelete()		|multiselect-Change.beforedelete()|
  Change.afterinsert()		|multiselect-Change.afterinsert()|
  Change.apply()		|multiselect-Change.apply()|

* Event class~
  Event				|multiselect-class-Event|
  Event.name			|multiselect-Event.name|
  Event.set()			|multiselect-Event.set()|
  Event.unset()			|multiselect-Event.unset()|
  Event.trigger()		|multiselect-Event.trigger()|
  Event.on()			|multiselect-Event.on()|
  Event.off()			|multiselect-Event.off()|
  Event.isactive()		|multiselect-Event.isactive()|
  Event.skip()			|multiselect-Event.skip()|

------------------------------------------------------------------------------
Multiselect module~
					*multiselect-module-Multiselect*

multiselect#import()			*multiselect#import()*
	This function returns a `Multiselect` module. >
		let s:Multiselect = multiselect#import()
<

				*multiselect-Multiselect.DEFAULTHIGROUP*
Multiselect.DEFAULTHIGROUP    [string]
	This is the default name of highlight group for the selected region,
	"MultiselectItem".


					*multiselect-Multiselect.load()*
Multiselect.load()    [function]
	This function returns the "global" `Multiselector` instance.
	See |multiselect-class-Multiselector|. >
		let s:multiselector = s:Multiselect.load()
<
	Users can communicate with the "global" instance with the provided
	keymappings |multiselect-keymappings|.


				*multiselect-Multiselect.Multiselector()*
Multiselect.Multiselector([{options}])    [function]
	This is a constructor of `Multiselector` class. A plugin developer can
	obtain a new `Multiselector` instance. Each `Multiselector` instance
	is independent, it does not affect to others.
	See |multiselect-class-Multiselector|.

	{options} is a |Dictionary| containing optional arguments.
	The following keys are available.
	  name:
	    The identifier of the instance. It does not affect its
	    functionality. It would be an empty string if omitted.

	  higroup:
	    The name of highlight group for selection areas. It would be
	    "MultiselectItem" if omitted.

	  eventinit:
	    The name of autocmd event triggered every time the Multiselect
	    instance is initialized. It would be an empty string if omitted,
	    and the autocmd event would not be triggered.
	    The initialization is called when:
	      - an instance is produced
	      - the cursor moved to another buffer
	      - the cursor moved to another tabpage

	  eventcheckpost:
	    The name of autocmd event triggered every time when buffer texts
	    are selected. It would be an empty string if omitted, and the
	    autocmd event would not be triggered.

	  eventuncheckpost:
	    The name of autocmd event triggered every time when selection
	    items are unselected. It would be an empty string if omitted, and
	    the autocmd event would not be triggered.
>
	let s:multiselector = s:Multiselect.Multiselector({
		\ 'name': 'multiselect',
		\ 'higroup': 'MultiselectItem',
		\ 'eventinit': 'MultiselectInit',
		\ 'eventcheckpost': 'MultiselectCheckPost',
		\ 'eventuncheckpost': 'MultiselectUncheckPost',
		\ })
<
	The new "local" (private) instance cannot be controlled by the
	provided mappings |multiselect-keymappings|, alternative keymappings
	should be defined by developers themselves. `Multiselector` instance
	has some basic functions for the keymappings, see
	|multiselect-class-Multiselector|.
	|multiselect-Multiselector.keymap_check()|
	|multiselect-Multiselector.keymap_checkpattern()|
	|multiselect-Multiselector.keymap_uncheck()|
	|multiselect-Multiselector.keymap_uncheckall()|
	|multiselect-Multiselector.keymap_undo()|
	|multiselect-Multiselector.keymap_multiselect()|


					*multiselect-Multiselect.Region()*
Multiselect.Region({head}[, {tail}[, {type}[, {extended}]]])    [function]
Multiselect.Region({lnum})
Multiselect.Region({startlnum}, {endlnum})
	This is a constructor of `Region` class, it is a class to represent a
	region of a buffer. See |multiselect-class-Region|.

	{head} and {tail} are the edge positions of the region. These
	positions are a list like a return value of |getpos()|.

	{type} is a kind of the region:
	  "char" or "v": character-wise region
	  "line" or "V": line-wise region
	  "block" or "\<C-v>": block-wise region
	A new region would be character-wise if {type} is omitted.

	{extended} is effective only when the region is block-wise. It is a
	boolean (0 or 1), if {extended} is |TRUE| (1) the end column of each
	line is extended to the end of line. See |v_$|.
	|FALSE| (0) if omitted.  >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let region = s:Multiselect.Region(head, tail, 'block', 1)
<
	With only {head}, it returns an character-wise `Region` instance of a
	character, its head and tail is same.

	With only {lnum}, it returns an line-wise `Region` instance
	representing the line {lnum}.

	With {startlnum} and {endlnum}, it returns an line-wise `Region`
	instance representing the range from {startlnum} to {endlnum}.


					*multiselect-Multiselect.Item()*
Multiselect.Item({head}[, {tail}[, {type}[, {extended}]]])   [function]
Multiselect.Item({lnum})
Multiselect.Item({startlnum}, {endlnum})
	This is a constructor of `Item` class, it is a subclass of `Region`
	class used for handling a selection region on a buffer.
	See |multiselect-class-Item|.

	The arguments are common with `Multiselect.Region()`.  >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let item = s:Multiselect.Item(head, tail, 'block', 1)
<

					*multiselect-Multiselect.percolate()*
Multiselect.percolate({expr}, {Filterexpr})    [function]
	This function removes items in |List| or |Dictionary| based on
	{Filterexpr}, it is a |Funcref|, and return the removed items.

	If {expr} is a |List|, this function evaluates {Filterexpr} for each
	item in {expr} with two arguments, an item index and an item itself,
	and removes the items that {Filterexpr} returns |TRUE|. The removed
	items are returned as another |List|. >
		let s:percolate = s:Multiselect.percolate
		let list = ['foo', 'bar', 'baz']
		let filtered = s:percolate(list, {i, item -> item[0] ==# 'b'})
		" filtered == ['bar', 'baz']
		" list == ['foo']
<
	If {expr} is a |Dictionary|, this function evaluates {Filterexpr} for
	each value in {expr} with a key and a value, and removes the items
	that {Filterexpr} returns |TRUE|. The removed items are returned as
	another |Dictionary|. >
		let dict = {'foo': 1, 'bar': 2, 'baz': 3}
		let filtered = s:percolate(dict, {key, val -> key[0] ==# 'b'})
		" dict == {'bar': 2, 'baz': 3}
		" filtered == {'foo': 1}
<
	This function is similar to |filter()| but it filters the items that
	{Filterexpr} is |FALSE| and returns the {expr} while this function
	filters the items that {Filterexpr} is |TRUE| and returns the filtered
	items.


					*multiselect-Multiselect.enumerate()*
Multiselect.enumerate({list}[, {start}])    [function]
	This function returns a list of lists of indexes and items. >
		let s:enumerate = s:Multiselect.enumerate
		let list = ['foo', 'bar', 'baz']
		let newlist s:enumerate(list)
		" newlist == [[0, 'foo'], [1, 'bar'], [2, 'baz']]
<
	If {start} is assigned, the indexes start from the number. >
		let list = ['foo', 'bar', 'baz']
		let newlist s:enumerate(list, 1)
		" newlist == [[1, 'foo'], [2, 'bar'], [3, 'baz']]
<

					*multiselect-Multiselect.str2type()*
Multiselect.str2type({str})    [function]
	This function returns a string representing a type of region.
	This function returns "char" if {str} is "char" or "v".
	This function returns "line" if {str} is "line" or "V".
	This function returns "block" if {str} is "block" or "<C-v>"
	(a single CTRL-V character). See |visualmode()|. >
		let s:str2type = s:Multiselect.str2type

		let type = str2type('char')
		" type ==# 'char'

		let type = str2type('v')
		" type ==# 'char'

		let type = str2type('line')
		" type ==# 'line'

		let type = str2type('V')
		" type ==# 'line'

		let type = str2type('block')
		" type ==# 'block'

		let type = str2type("\<C-v>")
		" type ==# 'block'
<
	This function ignores a number after "<C-v>". See |getregtype()|. >
		let type = str2type("\<C-v>10")
		" type ==# 'block'
<

				*multiselect-Multiselect.str2visualcmd()*
Multiselect.str2visualcmd({str})    [function]
	This function returns a string representing a type of region.
	This function returns "char" if {str} is "char" or "v".
	This function returns "line" if {str} is "line" or "V".
	This function returns "block" if {str} is "block" or "<C-v>"
	(a single CTRL-V character). See |visualmode()|. >
		let s:str2visualcmd = s:Multiselect.str2visualcmd

		let type = str2visualcmd('char')
		" type ==# 'v'

		let type = str2visualcmd('v')
		" type ==# 'v'

		let type = str2visualcmd('line')
		" type ==# 'V'

		let type = str2visualcmd('V')
		" type ==# 'V'

		let type = str2visualcmd('block')
		" type ==# "\<C-v>"

		let type = str2visualcmd("\<C-v>")
		" type ==# "\<C-v>"
<
	This function ignores a number after "<C-v>". See |getregtype()|. >
		let type = str2visualcmd("\<C-v>10")
		" type ==# "\<C-v>"
<

					*multiselect-Multiselect.inorderof()*
Multiselect.inorderof({pos1}, {pos2})    [function]
	This function returns |TRUE| if {pos1} is located former than {pos2}.
>
		let s:inorderof = s:Multiselect.inorderof

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inorderof([0, 2, 3, 0], [0, 3, 1, 0])
		" bool is TRUE

		let bool = s:inorderof([0, 2, 3, 0], [0, 1, 1, 0])
		" bool is FALSE

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 2, 0])
		" bool is FALSE

		let bool = s:inorderof([0, 2, 3, 0], [0, 2, 3, 0])
		" bool is FALSE
<

					*multiselect-Multiselect.inbetween()*
Multiselect.inbetween({pos}, {head}, {tail})    [function]
	This function returns |TRUE| is {pos} is in between {head} and {tail}.
>
		let s:inbetween = s:Multiselect.inbetween
		let pos = [0, 2, 3, 0]

		let bool = s:inbetween(pos, [0, 2, 2, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 3, 0], [0, 2, 4, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 2, 0], [0, 2, 3, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 3, 0], [0, 2, 3, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 1, 1, 0], [0, 3, 1, 0])
		" bool is TRUE

		let bool = s:inbetween(pos, [0, 2, 1, 0], [0, 2, 2, 0])
		" bool is FALSE

		let bool = s:inbetween(pos, [0, 2, 4, 0], [0, 2, 5, 0])
		" bool is FALSE
<


------------------------------------------------------------------------------
Multiselector class~
					*multiselect-class-Multiselector*

A developer can access to the "global" multiselector instance by
`Multiselect.load()` function. |multiselect-Multiselect.load()|

If you need a new (private) multiselector instance, the constructor of
`Multiselector` class is available with `Multiselect` module.
|multiselect-Multiselect.Multiselector()|

  - members
					*multiselect-Multiselector.name*
Multiselector.name    [string]
	The identifier of the `Multiselector` instance. It does not affect any
	functionality.


					*multiselect-Multiselector.bufnr*
Multiselector.bufnr    [number]
	The current buffer number belonging to.


					*multiselect-Multiselector.higroup*
Multiselector.higroup    [string]
	The highlight group name applied for the selection regions.


					*multiselect-Multiselector.itemlist*
Multiselector.itemlist    [list]
	The list of the current multiple selection items. The items are the
	instances of `Item` class.
	NOTE: Do not change this list directly, use the below methods instead.


  - main interfaces
					*multiselect-Multiselector.check()*
Multiselector.check({head}[, {tail}[, {type}[, {extended}]]])    [method]
Multiselector.check({lnum})
Multiselector.check({startlnum}, {endlnum})
Multiselector.check({region})
	This method produces an `Item` instance and add it into
	`Multiselector.itemlist`. This method returns the added item.
	|multiselect-Multiselector.itemlist|

	The arguments are common with `Multiselect.Region()`, and additionally
	an instance of `Region` class or its subclasses is also acceptable.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'block', 1)
		call s:multiselector.check(region)
<

					*multiselect-Multiselector.uncheck()*
Multiselector.uncheck({head}[, {tail}[, {type}[, {extended}]]])    [method]
Multiselector.uncheck({lnum})
Multiselector.uncheck({startlnum}, {endlnum})
Multiselector.uncheck({region})
	This method removes items in `Multiselector.itemlist`, it removes the
	items touching with the assigned region.
	|multiselect-Multiselector.itemlist|

	The arguments are common with `Multiselect.Region()`, and additionally
	an instance of `Region` class or its subclasses is also acceptable.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 1, 0]
		let tail = [0, 3, 1, 0]
		let region = s:Multiselect.Region(head, tail, 'line')
		call s:multiselector.uncheck(region)
<

				*multiselect-Multiselector.uncheckall()*
Multiselector.uncheckall()    [method]
	This method removes all the items from `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist| >
		call s:multiselector.uncheckall()
<

					*multiselect-Multiselector.emit()*
Multiselector.emit([{Filterexpr}])    [method]
	This method removes items from `Multiselector.itemlist` and returns a
	list of these items. |multiselect-Multiselector.itemlist|

	Without {Filterexpr}, it removes all the items. >
		let itemlist = s:multiselector.emit()
<
	With {Filterexpr}, this method evaluates {Filterexpr}, a |Funcref|,
	for each item in `Multiselector.itemlist` with two arguments,
	an item index and an item, and removes the items that {Filterexpr}
	returns |TRUE|.
	  - Example1: emit items inside the visual selection region >
		let head = getpos("'<")
		let tail = getpos("'>")
		let type = visualmode()
		let region = s:Multiselect.Region(head, tail, type)
		let itemlist = s:multiselector.emit(
			\ {_, item -> item.isinside(region)})
<
	  NOTE: You can use an alias `Multiselector.emit_inside()` instead.
	        |multiselect-Multiselector.emit_inside()|

	  - Example2: emit items touching the cursor >
		let curpos = getpos('.')
		let itemlist = s:multiselector.emit(
			\ {_, item -> item.touches(curpos)})
<
	  NOTE: You can use an alias `Multiselector.emit_touching()` instead.
	        |multiselect-Multiselector.emit_touching()|


				*multiselect-Multiselector.emit_inside()*
Multiselector.emit_inside({head}[, {tail}[, {type}[, {extended}]]])   [method]
Multiselector.emit_inside({lnum})
Multiselector.emit_inside({startlnum}, {endlnum})
Multiselector.emit_inside({region})
	This method removes items from `Multiselector.itemlist` and returns a
	list of these items. This method removes only the items inside the
	assigned region will be removed to return.
	|multiselect-Multiselector.itemlist|

	The arguments are common with `Multiselect.Region()`, and additionally
	an instance of `Region` class or its subclasses is also acceptable.
	|multiselect-Multiselect.Region()| >
		let head = getpos("'<")
		let tail = getpos("'>")
		let type = visualmode()
		let region = s:Multiselect.Region(head, tail, type)
		let itemlist = s:multiselector.emit_inside(region)
<
	This actually equals to the above Example1 in `Multiselector.emit()`.
	|multiselect-Multiselector.emit()|


				*multiselect-Multiselector.emit_touching()*
Multiselector.emit_touching({head}[, {tail}[, {type}[, {extended}]]]) [method]
Multiselector.emit_touching({lnum})
Multiselector.emit_touching({startlnum}, {endlnum})
Multiselector.emit_touching({region})
	This method removes items from `Multiselector.itemlist` and returns a
	list of these items. This method removes only the items touching the
	assigned region will be removed to return.
	|multiselect-Multiselector.itemlist|

	The arguments are common with `Multiselect.Region()`, and additionally
	an instance of `Region` class or its subclasses is also acceptable.
	|multiselect-Multiselect.Region()| >
		let curpos = getpos('.')
		let itemlist = s:multiselector.emit_touching(curpos)
<
	This actually equals to the above Example2 in `Multiselector.emit()`.
	|multiselect-Multiselector.emit()|


					*multiselect-Multiselector.filter()*
Multiselector.filter({Filterexpr})    [method]
	This method filters the items in  `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|

	{Filterexpr} is an |Funcref|. {Filterexpr} is evaluated for each item
	in `Multiselector.itemlist`, and when the result is FALSE, this
	function removes the item. The resulted `Multiselector.itemlist` is
	returned.
	  - Example1: filter items except in line 5 >
		let pos = [0, 5, 1, 0]
		let line5 = s:Multiselect.Region(pos, pos, 'V')
		call s:Multiselector.filter(
			\ {_, item -> item.isinside(line5)})
<
	|multiselect-Multiselect.Region()|
	|multiselect-class-Region| |multiselect-class-Item|
	|multiselect-Region.isinside()|

	  - Example2: filter items outside the visual selection >
		let vhead = getpos("'<")
		let vtail = getpos("'>")
		let vmode = visualmode()
		let visual = s:Multiselect.Region(vhead, vtail, vmode)
		call s:Multiselector.filter(
			\ {_, item -> item.isinside(visual)})
<
	|multiselect-Multiselect.Region()|
	|multiselect-class-Region| |multiselect-class-Item|
	|multiselect-Region.isinside()|


					*multiselect-Multiselector.sort()*
Multiselector.sort({itemlist})    [method]
	This method sorts the items in {itemlist}. An item in {itemlist}
	should be an instance of `Region` class or its subclasses. An item
	closer to the beginning of a buffer comes to the earlier order in the
	{itemlist}; however if blockwise items and characterwise items are in
	a same line, these items are sorted by screen columns. The items at
	left-side comes earlier. >
		"#" represents selection and the number is the index in the
		sorted list

		##1##	#####	##4##
			##3##
		##2##	#####	##5##
<
	The sort operation is done in-place, thus this is destructive to
	{itemlist}. If you want a {itemlist} to remain unmodified make a copy
	first: >
		let copied = copy(itemlist)
		call s:Multiselector.sort(copied)
<

  - keymap interfaces
				*multiselect-Multiselector.keymap_check()*
Multiselector.keymap_check({mode})    [method]
	This method is employed to define a keymapping to communicate with the
	`Multiselector` instance.

	This method registers a current visual selection area as a multiple
	selection area. In normal mode, it registers a |word| under the
	cursor.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode. >
		let s:Multiselect = multiselect#import()
		let s:private_ms = s:Multiselect.Multiselector()
		function! s:check(mode) abort
		  call s:private_ms.keymap_check(a:mode)
		endfunction
		nnoremap <Plug>(check) :<C-u>call <SID>check('n')<CR>
		xnoremap <Plug>(check) <Esc>:call <SID>check('x')<CR>
<
	|multiselect#import()|
	|multiselect-Multiselect.Multiselector()|


			     *multiselect-Multiselector.keymap_checkpattern()*
Multiselector.keymap_checkpattern({mode}, {pat})    [method]
	This method is employed to define a keymapping to communicate with the
	`Multiselector` instance.

	This method registers the texts matching with the given regular
	expression pattern {pat}. In normal mode, it registers all the matched
	texts in the current buffer. In visual mode, it registers the matched
	pattern in the visual-selected range.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode. >
		let s:Multiselect = multiselect#import()
		let s:private_ms = s:Multiselect.Multiselector()
		function! s:checksearch(mode) abort
		  call s:private_ms.keymap_checkpattern(a:mode, @/)
		endfunction
		nnoremap <Plug>(checks) :<C-u>call <SID>checksearch('n')<CR>
		xnoremap <Plug>(checks) <Esc>:call <SID>checksearch('x')<CR>
<
	|multiselect#import()|
	|multiselect-Multiselect.Multiselector()|


				*multiselect-Multiselector.keymap_uncheck()*
Multiselector.keymap_uncheck({mode})    [method]
	This method is employed to define a keymapping to communicate with the
	`Multiselector` instance.

	This method deletes registered multiple selet items. In normal mode,
	it deletes an item under the cursor. In visual mode, it deletes
	registered items in the current visual-selected range.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode. >
		let s:Multiselect = multiselect#import()
		let s:private_ms = s:Multiselect.Multiselector()
		function! s:uncheck(mode) abort
		  call s:private_ms.keymap_uncheck(a:mode)
		endfunction
		nnoremap <Plug>(uncheck) :<C-u>call <SID>uncheck('n')<CR>
		xnoremap <Plug>(uncheck) <Esc>:call <SID>uncheck('x')<CR>
<
	|multiselect#import()|
	|multiselect-Multiselect.Multiselector()|


			       *multiselect-Multiselector.keymap_uncheckall()*
Multiselector.keymap_uncheckall()    [method]
	This method is employed to define a keymapping to communicate with the
	`Multiselector` instance.

	This method deletes all registered items. >
		let s:Multiselect = multiselect#import()
		let s:private_ms = s:Multiselect.Multiselector()
		function! s:uncheckall() abort
		  call s:private_ms.keymap_uncheckall()
		endfunction
		nnoremap <Plug>(uncheckall) :<C-u>call <SID>uncheckall()<CR>
		xnoremap <Plug>(uncheckall) <Esc>:call <SID>uncheckall()<CR>
<
	|multiselect#import()|
	|multiselect-Multiselect.Multiselector()|


				*multiselect-Multiselector.keymap_undo()*
Multiselector.keymap_undo()    [method]
	This method is employed to define a keymapping to communicate with the
	`Multiselector` instance.

	This method undo the last check or uncheck action. This undo itself is
	an action, thus the undo action will be undone by the subsequent call
	of .keymap_undo(). That is, the undo depth is currently only one
	times.


			      *multiselect-Multiselector.keymap_multiselect()*
Multiselector.keymap_multiselect({mode})    [method]
	This method is employed to define a keymapping to communicate with the
	`Multiselector` instance.

	In |Normal| mode, this method removes an item under the cursor if the
	text is selected. Otherwise this method selects the |word| under the
	cursor over the current buffer.

	In |Visual| mode, this method filters out the items outside the visual
	selection. If no item is inside, this method selects it.
	Especially with character-wise selection, this method selects the
	selected word over the current buffer.

	{mode} is a character representing the mode mapped; 'n' for |Normal|
	mode, 'x' for |Visual| mode. >
		let s:Multiselect = multiselect#import()
		let s:private_ms = s:Multiselect.Multiselector()
		function! s:toggle(mode) abort
		  call s:private_ms.keymap_toggle(a:mode)
		endfunction
		nnoremap <Plug>(toggle) :<C-u>call <SID>toggle('n')<CR>
		xnoremap <Plug>(toggle) <Esc>:call <SID>toggle('x')<CR>
<
	|multiselect#import()|
	|multiselect-Multiselect.Multiselector()|


  - low-level interfaces
					*multiselect-Multiselector.extend()*
Multiselector.extend({itemlist})    [method]
	This method extends `Multiselector.itemlist` to append items in
	{itemlist}. The items in {itemlist} should be instances of `Item`
	class. The items are appended at the end of `Multiselector.itemlist`.
	This method returns `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|
>
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]

		call s:multiselector.extend(itemlist)
		" s:multiselector.itemlist == [item1, item2, item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|


					*multiselect-Multiselector.add()*
Multiselector.add({item})    [method]
	This method add an {item} to `Multiselector.itemlist`. The {item}
	should be an instance of `Item` class. The item is appended at the
	end of `Multiselector.itemlist`. This method returns
	`Multiselector.itemlist`. |multiselect-Multiselector.itemlist|
 >
		call s:multiselector.uncheckall()
		let item = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])

		call s:multiselector.add(item)
		" s:multiselector.itemlist == [item]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|


					*multiselect-Multiselector.remove()*
Multiselector.remove({idx}[, {end}])    [method]
Multiselector.remove({indexlist})
	This method removes the item in  `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|

	Without {end}: Remove the item at {idx} from `Multiselector.itemlist`
	and return the item. >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.extend(itemlist)

		let lastitem = s:multiselector.remove(-1)
		" lastitem is item3
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.extend()|

	With {end}: Remove items from {idx} to {end} and return a |List| of
	these items. >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.extend(itemlist)

		let removeditems = s:multiselector.remove(0, 1)
		" removeditems == [item1, item2]
<
	This method can removes the item also by a list of indexes. >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.extend(itemlist)

		let removed = s:multiselector.remove([0, 2])
		" removed is [item1, item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.extend()|


				*multiselect-Multiselector.enumerate()*
Multiselector.enumerate([{Filterexpr}])    [method]
	This method returns a list of lists of an index and an item.
	Note that this method does not change uncheck the returned items,
	not like `Multiselector.emit()`.
	|multiselect-Multiselector.emit()| >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.extend(itemlist)

		let list = s:multiselector.enumerate()
		" list == [[0, item1], [1, item2], [2, item3]]
<
	With {Filterexpr}, it returns the items that {Filterexpr} return
	|TRUE|. {Filterexpr} is a |Funcref| and it is evaluated for each
	item in `Multiselector.itemlist` with two arguments, an item index and
	an item itself. >
		let list = s:multiselector.enumerate(
		         \ {index, item -> item.head[2] != 2})
		" list == [[0, item1], [2, item3]]
<

					*multiselect-Multiselector.itemnum()*
Multiselector.itemnum([{Filterexpr}])    [method]
	This method returns the number of items in  `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist| >
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.extend(itemlist)

		let nr = s:multiselector.itemnum()
		" nr == 3
<
	{Filterexpr} is a |Funcref|. If {Filterexpr} is assigned, this method
	evaluates {Filterexpr} for each items and count the number of items
	which {Filterexpr} returns |TRUE|. The {Filterexpr} is evaluated with
	two arguments, index of the item and the item itself. The item is an
	instance of `Item` class. >
		" count the number of items in line 1
		call s:multiselector.itemnum({i, item -> item.head[1] == 1})
<

					*multiselect-Multiselector.isempty()*
Multiselector.isempty()    [method]
	This method returns a boolean; |TRUE| if `Multiselector.itemlist` is
	empty, otherwise |FALSE|. |multiselect-Multiselector.itemlist| >
		call s:multiselector.uncheckall()
		let bool = s:multiselector.isempty()
		" bool is 1

		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.extend(itemlist)

		let bool = s:multiselector.isempty()
		" bool is 0
<

				*multiselect-Multiselector.lastevent()*
Multiselector.lastevent()    [method]
	This method returns a history of the last event; check or uncheck. The
	return value is a dictionary which have the following keys.
	  event: "check" of "uncheck"
	  itemlist: a list of checked or unchecked items
>
		call s:multiselector.uncheckall()
		let item1 = s:Multiselect.Item([0, 1, 1, 0], [0, 1, 1, 0])
		let item2 = s:Multiselect.Item([0, 1, 2, 0], [0, 1, 2, 0])
		let item3 = s:Multiselect.Item([0, 1, 3, 0], [0, 1, 3, 0])
		let itemlist = [item1, item2, item3]
		call s:multiselector.extend(itemlist)

		let last = s:multiselector.lastevent()
		" last.event ==# 'check'
		" last.itemlist == [item1, item2, item3]

		call s:multiselector.remove(-1)

		let last = s:multiselector.lastevent()
		" last.event ==# 'uncheck'
		" last.itemlist == [item3]
<
	|multiselect-Multiselector.uncheckall()|
	|multiselect-Multiselect.Item()|
	|multiselect-Multiselector.extend()|
	|multiselect-Multiselector.remove()|


					*multiselect-Multiselector.show()*
Multiselector.show()    [method]
	This method highlight all the items in `Multiselector.itemlist`.
	|multiselect-Multiselector.itemlist|

	Unless you turned off the highlightings by `Multiselector.quench()`
	intentionally, you don't need to use this method.
	|multiselect-Multiselector.quench()|
>
		" hide multiple selection
		call s:multiselector.quench()

		" show up again
		call s:multiselector.show()
<

					*multiselect-Multiselector.quench()*
Multiselector.quench()    [method]
	This method turns off the highlightings of multiple selection items on
	the current buffer. It does not unselect, just hide. You can use
	`Multiselector.show()` to highlight them again.
	|multiselect-Multiselector.show()|
>
		" hide multiple selection
		call s:multiselector.quench()

		" show up again
		call s:multiselector.show()
<

  - event controls
					*multiselect-Multiselector.event*
Multiselector.event.BufLeave       [Event-instance]
Multiselector.event.TabLeave       [Event-instance]
Multiselector.event.CmdwinEnter    [Event-instance]
Multiselector.event.CmdwinLeave    [Event-instance]
Multiselector.event.TextChanged    [Event-instance]
Multiselector.event.InsertEnter    [Event-instance]
Multiselector.event.WinNew         [Event-instance]
Multiselector.event.Init           [Event-instance]
Multiselector.event.CheckPost      [Event-instance]
Multiselector.event.UncheckPost    [Event-instance]
	These objects are employed to control the behavior on autocmd events.
	Check |multiselect-class-Event|.

	`Multiselector.event.BufLeave` controls the behavior on |BufLeave|
	event. An initialization process is executed in default; all the items
	are unchecked and clear |multiselect-Multiselector.bufnr|.

	`Multiselector.event.TabLeave` controls the behavior on |TabLeave|
	event. An initialization process is executed in default; all the items
	are unchecked and clear |multiselect-Multiselector.bufnr|.

	`Multiselector.event.CmdwinEnter` controls the behavior on
	|CmdwinEnter| event. A pending process is executed in default; some
	information of `Multiselector` instance is saved and switched to the
	one for the |command-line-window| temporary.

	`Multiselector.event.CmdwinLeave` controls the behavior on
	|CmdwinLeave| event. An initialization process and a resume process
	are executed in default; the saved information in the previous pending
	process is restored.

	`Multiselector.event.TextChanged` controls the behavior on
	|TextChanged| event. All the multiselect items in the current buffer
	are unchecked in default.

	`Multiselector.event.InsertEnter` controls the behavior on
	|InsertEnter| event. All the multiselect items in the current buffer
	are unchecked in default.

	`Multiselector.event.WinNew` controls the behavior on |WinNew| event.
	If the new window displays the same buffer, the multiselect items on
	the window are highlighted.

	`Multiselector.event.Init` controls the behavior on
	|MultiselectInit| event.

	`Multiselector.event.CheckPost` controls the behavior on
	|MultiselectCheckPost| event.

	`Multiselector.event.UncheckPost` controls the behavior on
	|MultiselectUncheckPost| event.

	NOTE: Change in the event controls may cause a serious problem on the
	      multiselect functionality. Use them very carefully.



------------------------------------------------------------------------------
Region class~
					*multiselect-class-Region*

The constructor of `Region` class is available with `Multiselect` module.
|multiselect-Multiselect.Region()|

					*multiselect-Region.head*
Region.head    [list]
	This is the head position of the `Region` on a buffer. It is an
	four-item list and can be used for the argument of |setpos()|. >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call setpos('.', region.head)
		" getpos('.') == head
<

					*multiselect-Region.tail*
Region.tail    [list]
	This is the tail position of the `Region` on a buffer. It is an
	four-item list and can be used for the argument of |setpos()|. >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call setpos('.', region.tail)
		" getpos('.') == tail
<

					*multiselect-Region.type*
Region.type    [string]
	This is a string standing for the type of the `Region`; "char", "line"
	or "block".


					*multiselect-Region.extended*
Region.extended    [boolean]
	This is a boolean which is effective only when the `Region` is
	block-wise. It is |TRUE| if the end column of each line is extended to
	the end of line, otherwise |FALSE| (0). See |v_$|.


					*multiselect-Region.select()*
Region.select()    [method]
	This method selects the area of `Region`.
	  - Example: Delete a Region >
		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region = s:Multiselect.Region(head, tail, 'char')

		call region.select()
		normal! d
<
	  This is almost same as: >
		normal! v
		call setpos('.', [0, 1, 1, 0])
		normal! o
		call setpos('.', [0, 1, 3, 0])
		normal! d
<
	This method can handle also line-wise and block-wise region
	appropriately.


					*multiselect-Region.yank()*
Region.yank()    [method]
	This method yank the text of the `Region` and return the string. >
		call setline(1, 'foo bar baz')
		let head = [0, 1, 5, 0]
		let tail = [0, 1, 7, 0]
		let region = s:Multiselect.Region(head, tail, 'char')
		let text = region.yank()
		echo text   " bar
<

					*multiselect-Region.includes()*
Region.includes({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.includes({lnum})
Region.includes({startlnum}, {endlnum})
Region.includes({region})
	This method returns |TRUE| if the `Region` instance includes an
	assigned region, otherwise |FALSE|.

	The arguments are common with `Multiselect.Region()`, and additionally
	an instance of `Region` class or its subclasses is also acceptable.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.includes([0, 1, 1, 0])
		" bool is FALSE

		let bool = region1.includes([0, 1, 2, 0])
		" bool is TRUE

		let bool = region1.includes(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.includes(region2)
		" bool is FALSE

		let head = [0, 1, 2, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.includes(region3)
		" bool is TRUE
<

					*multiselect-Region.isinside()*
Region.isinside({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.isinside({lnum})
Region.isinside({startlnum}, {endlnum})
Region.isinside({region})
	This method returns |TRUE| if the `Region` instance is inside an
	assigned region, otherwise |FALSE|.

	The arguments are common with `Multiselect.Region()`, and additionally
	an instance of `Region` class or its subclasses is also acceptable.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.isinside(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region2)
		" bool is FALSE

		let head = [0, 1, 2, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region3)
		" bool is FALSE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 5, 0]
		let region4 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.isinside(region4)
		" bool is TRUE
<

					*multiselect-Region.touches()*
Region.touches({head}[, {tail}[, {type}[, {extended}]]])    [method]
Region.touches({lnum})
Region.touches({startlnum}, {endlnum})
Region.touches({region})
	This method returns |TRUE| if the `Region` instance is touching an
	assigned region, otherwise |FALSE|.

	The arguments are common with `Multiselect.Region()`, and additionally
	an instance of `Region` class or its subclasses is also acceptable.
	|multiselect-Multiselect.Region()| >
		let head = [0, 1, 2, 0]
		let tail = [0, 1, 4, 0]
		let region1 = s:Multiselect.Region(head, tail, 'char')

		let bool = region1.touches([0, 1, 1, 0])
		" bool is FALSE

		let bool = region1.touches([0, 1, 2, 0])
		" bool is TRUE

		let bool = region1.touches([0, 1, 4, 0])
		" bool is TRUE

		let bool = region1.touches([0, 1, 5, 0])
		" bool is FALSE

		let bool = region1.touches(region1)
		" bool is TRUE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 2, 0]
		let region2 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region2)
		" bool is FALSE

		let head = [0, 1, 1, 0]
		let tail = [0, 1, 3, 0]
		let region3 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region3)
		" bool is TRUE

		let head = [0, 1, 4, 0]
		let tail = [0, 1, 6, 0]
		let region4 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region4)
		" bool is TRUE

		let head = [0, 1, 5, 0]
		let tail = [0, 1, 6, 0]
		let region5 = s:Multiselect.Region(head, tail, 'char')
		let bool = region1.touches(region5)
		" bool is FALSE
<


------------------------------------------------------------------------------
Item class~
					*multiselect-class-Item*

The constructor of `Item` class is available with `Multiselect` module.
|multiselect-Multiselect.Item()|

`Item` class is a subclass of `Region` class, thus `Item` class inherites all
the properties of `Region` class.

					*multiselect-Item.id*
Item.id    [number]
	This is a number specific for each item.


					*multiselect-Item.bufnr*
Item.bufnr    [number]
	This is a buffer number of the item belonging to.


					*multiselect-Item.show()*
Item.show()    [method]
	This is a method to highlight the item region on a buffer.


					*multiselect-Item.quench()*
Item.quench()    [method]
	This is a method to turn off the highlight of the item.



------------------------------------------------------------------------------
Change class~
					*multiselect-class-Change*

This is an utility class to track a position after deletions and additions of
texts into the current buffer. It might be useful when a plugin developer
makes a new plugin to do well with |multiselect.vim|

Note that the `Change` class instance cannot track the change by 'autoindent'
option and its relatives ('smartindent', 'cindent', 'indentexpr') perfectly.

					*multiselect-Change.beforedelete()*
Change.beforedelete({head}[, {tail}[, {type}[, {extended}]]])    [method]
Change.beforedelete({lnum})
Change.beforedelete({startlnum}, {endlnum})
Change.beforedelete({region})
	This method should be called before deleting a text on the current
	buffer to record the region. The deletion is regarded as an
	|inclusive| delete action. Thus the last character pointed by {tail}
	is included.

	This method returns the `Change` instance itself.


					*multiselect-Change.afterinsert()*
Change.afterinsert({head}[, {tail}[, {type}[, {extended}]]])    [method]
Change.afterinsert({lnum})
Change.afterinsert({startlnum}, {endlnum})
Change.afterinsert({region})
	This method should be called after adding a text into the current
	buffer to record the region. The {tail} should point the ending edge
	of the insertion.

	This method returns the `Change` instance itself.


					*multiselect-Change.apply()*
Change.apply(pos)    [method]
Change.apply(region)
	This method calculates the position after a series of editings.
	This method updates the position (or a `Region` instance) in-place and
	returns it.


  - Usage
The current buffer is like this. >
	foo bar baz
<
For example, if you want to track the cursor position after an edit, you
need to save the cursor position. >
	let curpos = getpos('.')
<
The cursor is on the 'z' of "baz" and then you are going to delete "bar" and
insert "x" instead.
Before deleting, you need to call `Change.beforedelete()`. >
	let bar = s:Multiselect.Region([0, 1, 5, 0], [0, 1, 7, 0], 'char')
	let change = s:Multiselect.Change()
	call change.beforedelete(bar)
<
Edit the buffer. >
	call bar.select()
	normal! cx
<
Now the buffer is: >
	foo x baz
<
After inserting a text, you need to call `Change.afterinsert()`. >
	call change.afterinsert(getpos("'["), getpos("']"), 'char')
<
After those processes, use `Change.apply()` to update the cursor position. >
	call change.apply(curpos)
	" curpos == [0, 1, 9, 0]
<
Finally you can move the cursor to the new position taking into account the
last edit. >
	call setpos('.', curpos)
<


------------------------------------------------------------------------------
Event class~
					*multiselect-class-Event*

					*multiselect-Event.name*
Event.name    [string]
	The name of autocmd event responsible for.


					*multiselect-Event.set()*
Event.set({expr})    [method]
	This method sets an autocmd task {expr}. {expr} should be a |String|
	or a |Funcref|.

	If {expr} is a |String| it is |:execute|d as a command-line command. >
		call s:multiselector.event.BufLeave.set('echo "BufLeave"')
<
	If {expr} is a |Funcref| it is called with an argument, the event
	name. >
		call s:multiselector.event.BufLeave.set(
			\ {event -> execute('echo "' . event . '"')})
<
	This method returns a number, this is a {eventid} which is specific
	for each autocmd task and is used to unset the task by
	`Event.unset()` method. >
		let id = s:multiselector.event.BufLeave.set('echo "BufLeave"')
		call s:multiselector.event.BufLeave.unset(id)
<

					*multiselect-Event.unset()*
Event.unset({eventid})    [method]
	This method removes an autocmd task corresponding to {eventid}.
	{eventid} is a return value of `Event.set()` method. >
		let id = s:multiselector.event.BufLeave.set('echo "BufLeave"')
		call s:multiselector.event.BufLeave.unset(id)
<

					*multiselect-Event.trigger()*
Event.trigger()    [method]
	This method execute all the registered autocmd task.


					*multiselect-Event.on()*
Event.on()    [method]
	This method activate the `Event` tasks.


					*multiselect-Event.off()*
Event.off()    [method]
	This method deactivate the `Event` tasks.


					*multiselect-Event.isactive()*
Event.isactive()    [method]
	This method returns |TRUE| if the `Event` is activated, |FALSE| if it
	is deactivated.


					*multiselect-Event.skip()*
Event.skip([{count}])    [method]
	If this method is called, the following `Event` tasks are skipped
	(not executed) {count} times. {count} is 1 if omitted.


==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet::fdl=0:fen:fdm=marker:noet:
